<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>MTMET — Video Call PRO</title>
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='16' fill='%2312192a'/%3E%3Ctext x='50'%20y='58' font-size='52' text-anchor='middle' fill='%23ffffff' font-family='Arial'%3EM%3C/text%3E%3C/svg%3E">
<style>
:root{--bg:#0b1b2b;--surface:#12161a;--accent:#2196f3;--muted:#9fb0bd;--text:#e8eaed;--danger:#b71c1c;--tile-radius:14px}
body{margin:0;height:100vh;background:var(--bg);color:var(--text);font-family:Inter,Segoe UI,Arial;display:flex;flex-direction:column}
header{display:flex;align-items:center;gap:12px;padding:12px 18px;background:linear-gradient(90deg,rgba(33,150,243,0.06),transparent);border-bottom:1px solid rgba(255,255,255,0.03)}
.logo{width:44px;height:44px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#64b5f6);display:flex;align-items:center;justify-content:center;font-weight:700}
.header-right{margin-left:auto;display:flex;gap:8px;align-items:center}
#roomTitle{font-weight:700}
#meInfo{font-size:13px;color:var(--muted)}
#inviteBtn{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--accent);padding:8px;border-radius:8px;cursor:pointer}
#stageWrap{flex:1;overflow:auto;padding:16px}
#stage{display:grid;gap:12px;align-content:start}
.tile{background:#000;border-radius:var(--tile-radius);overflow:hidden;position:relative;min-height:150px;display:flex;align-items:center;justify-content:center}
.tile video{width:100%;height:100%;object-fit:cover;display:block}
.tile .avatar{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:48px;font-weight:700;background:linear-gradient(135deg,#263238,#37474f);color:#fff}
.tile .bottomBar{position:absolute;left:12px;right:12px;bottom:12px;display:flex;align-items:center;justify-content:space-between;gap:8px}
.badge{background:rgba(0,0,0,0.45);padding:6px 10px;border-radius:10px;font-weight:600;color:var(--text)}
.micDot{width:10px;height:10px;border-radius:50%;background:#6b6b6b;margin-left:8px;box-shadow:0 0 0 0 rgba(0,0,0,0)}
.micOn{background:#00e676;box-shadow:0 0 8px rgba(0,230,118,0.18)}
.controls{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:var(--surface);padding:12px 14px;border-radius:40px;display:flex;gap:10px;box-shadow:0 10px 60px rgba(0,0,0,0.6);z-index:40}
.controlBtn{width:56px;height:56px;border-radius:50%;border:none;background:var(--accent);color:#fff;cursor:pointer;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:14px}
.controlBtn.dim{filter:grayscale(60%) brightness(0.6)}
.controlBtn.danger{background:var(--danger)}
.controlBtn.no-perm{background:#4e1a1a}
.controlBtn.mic-active{box-shadow:0 0 18px rgba(0,230,118,0.22);}
/* Popup invite */
.popup{position:fixed;inset:0;background:rgba(0,0,0,0.55);display:flex;align-items:center;justify-content:center;z-index:999}
.popup.hidden{display:none}
.popupContent{width:360px;max-height:75vh;background:var(--surface);border-radius:14px;overflow:auto;padding:14px;box-shadow:0 0 40px rgba(0,0,0,0.4)}
.popupHeader{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;font-size:18px;font-weight:600}
.closeBtn{border:none;background:transparent;color:var(--muted);font-size:18px;cursor:pointer}
.friendList .item{display:flex;align-items:center;justify-content:space-between;padding:10px;border-radius:10px;background:rgba(255,255,255,0.02);margin-bottom:8px}
.friendAvatar{width:40px;height:40px;background:linear-gradient(135deg,#455a64,#607d8b);border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:18px}
.inviteBtn{padding:6px 10px;border-radius:8px;border:none;cursor:pointer;background:var(--accent);color:#fff}
.inviteBtn.sent{background:#4e1a1a;cursor:not-allowed}
@media (min-width:1400px){#stage{grid-template-columns:repeat(4,1fr)}}
@media (max-width:1399px) and (min-width:900px){#stage{grid-template-columns:repeat(3,1fr)}}
@media (max-width:899px) and (min-width:600px){#stage{grid-template-columns:repeat(2,1fr)}}
@media (max-width:599px){#stage{grid-template-columns:repeat(1,1fr)}}
.small{font-size:13px;color:var(--muted)}
.hidden{display:none}
</style>
</head>
<body>

<header>
  <div class="logo">M</div>
  <div>
    <div id="roomTitle">Room</div>
    <div id="meInfo" class="small">...</div>
  </div>
  <div class="header-right">
    <div id="meName" class="small"></div>
    <button id="inviteBtn">Invite</button>
  </div>
</header>

<div id="stageWrap"><div id="stage"></div></div>

<!-- On-screen debug panel (for diagnosing signaling/ICE) -->
<div id="debugPanel" style="position:fixed;right:12px;bottom:90px;width:340px;max-height:40vh;overflow:auto;background:rgba(0,0,0,0.65);padding:10px;border-radius:10px;color:#e8eaed;font-size:12px;z-index:1000">
  <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
    <strong>DEBUG</strong>
    <div style="display:flex;gap:6px">
      <button id="dbgClear" style="background:transparent;border:1px solid rgba(255,255,255,0.06);color:#fff;padding:4px;border-radius:6px;cursor:pointer">Clear</button>
    </div>
  </div>
  <div id="dbgContent" style="white-space:pre-wrap;line-height:1.3;max-height:32vh;overflow:auto"></div>
</div>

<div class="controls">
  <button id="requestPermBtn" class="controlBtn" title="Enable Camera & Mic">SET</button>
  <button id="muteBtn" class="controlBtn dim" title="Toggle mic">MIC</button>
  <button id="camBtn" class="controlBtn dim" title="Toggle cam">CAM</button>
  <button id="leaveBtn" class="controlBtn danger" title="Leave">✖</button>
</div>

<!-- Invite Popup -->
<div id="invitePopup" class="popup hidden">
  <div class="popupContent">
    <div class="popupHeader">
      <div>Chọn bạn để mời</div>
      <button id="closeInvite" class="closeBtn">✖</button>
    </div>
    <div id="friendList" class="friendList"></div>
  </div>
</div>

<script src="firebase-config.js"></script>
<script type="module">
import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js';
import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-auth.js';
import { getDatabase, ref, set, onValue, push, get, remove } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-database.js';

const app = initializeApp(window.FIREBASE_CONFIG);
const auth = getAuth(app);
const db = getDatabase(app);

console.debug('call.html loaded with DB URL:', window.FIREBASE_CONFIG && window.FIREBASE_CONFIG.databaseURL);

// Debug helpers
const dbgContent = document.getElementById('dbgContent');
const dbgClear = document.getElementById('dbgClear');
function dbg(msg){
  const ts = new Date().toLocaleTimeString();
  const line = `[${ts}] ${msg}`;
  if(dbgContent){ dbgContent.innerText = line + '\n' + dbgContent.innerText; }
  console.debug(line);
}
dbgClear.onclick = ()=>{ if(dbgContent) dbgContent.innerText = ''; };

const peerStates = {}; // uid -> state
function updatePeerState(pid, state){ peerStates[pid]=state; dbg(`Peer ${pid} state: ${state}`); renderPeerStates(); }
function renderPeerStates(){ let s=''; for(const p in peerStates){ s += `${p}: ${peerStates[p]}\n`; } if(dbgContent) dbgContent.innerText = s + '\n' + dbgContent.innerText; }

// Check auth state and wait for user data to load
let authReadyPromise = new Promise((resolve) => {
  onAuthStateChanged(auth, async user => {
    if (!user) {
      location.href = 'login.html';
      return;
    }
    window.currentUser = { uid: user.uid };
    console.debug('call.html auth user:', user.uid);
    
    // Load user display name from DB
    try {
      const userSnap = await get(ref(db, `users/${user.uid}`));
      const userData = userSnap.val();
      if (userData) {
        window.currentUser.displayName = userData.displayName;
        window.currentUser.username = userData.username;
        console.debug('call.html user data loaded:', window.currentUser);
      } else {
        console.warn('User data not found for:', user.uid);
      }
    } catch (e) {
      console.error('Error loading user data:', e);
    }
    resolve(window.currentUser);
  });
});


const stage = document.getElementById('stage');
const meInfo = document.getElementById('meInfo');
const meName = document.getElementById('meName');
const inviteBtn = document.getElementById('inviteBtn');
const requestPermBtn = document.getElementById('requestPermBtn');
const muteBtn = document.getElementById('muteBtn');
const camBtn = document.getElementById('camBtn');
const leaveBtn = document.getElementById('leaveBtn');
const invitePopup = document.getElementById('invitePopup');
const friendListDiv = document.getElementById('friendList');
const closeInvite = document.getElementById('closeInvite');

let roomId = new URLSearchParams(location.search).get('room') || "demo-room";

// Will be filled from Firebase auth (via Promise)
let uid = null;
let username = null;
let displayName = null;

// Wait for auth to be ready
authReadyPromise.then(() => {
  const user = window.currentUser;
  uid = user.uid;
  username = user.username;
  displayName = user.displayName || user.username;
  
  console.debug('Auth ready - uid:', uid, 'username:', username, 'displayName:', displayName);
  
  meName.innerText = displayName;
  meInfo.innerText = uid;
  
  // Enable the SET button now that auth is ready
  requestPermBtn.disabled = false;
  requestPermBtn.style.opacity = '1';
}).catch(err => {
  console.error('Failed to load auth:', err);
  alert('Lỗi tải thông tin người dùng');
});

let localStream=null;
let localMicEnabled=false;
let localCamEnabled=false;
let pcs = {};
let tiles = {};
let audioAnalyzers = {};

function elt(t,attrs={},txt=''){ const e=document.createElement(t); for(const k in attrs) e.setAttribute(k,attrs[k]); if(txt) e.innerText=txt; return e; }
function relayout(){ const count=Object.keys(tiles).length||1; const w=stage.clientWidth; let cols=1; if(w>=1400) cols=Math.min(4,count); else if(w>=900) cols=Math.min(3,count); else if(w>=600) cols=Math.min(2,count); else cols=1; stage.style.gridTemplateColumns=`repeat(${cols},1fr)`;}
window.addEventListener('resize',relayout);

function createTile(uid,name){
  if(tiles[uid]) return tiles[uid];
  const tile = elt('div',{class:'tile'});
  const video = elt('video',{autoplay:true,playsinline:true});
  const safeName = (name && String(name).trim()) ? String(name).trim() : 'U';
  const avatarInitial = (safeName && safeName[0]) ? safeName[0].toUpperCase() : 'U';
  const avatar = elt('div',{class:'avatar'},avatarInitial);
  const bottomBar = elt('div',{class:'bottomBar'});
  const badge = elt('div',{class:'badge'},name);
  const micDot = elt('div',{class:'micDot'});
  bottomBar.appendChild(badge); bottomBar.appendChild(micDot);
  tile.appendChild(video); tile.appendChild(avatar); tile.appendChild(bottomBar);
  stage.appendChild(tile);
  tiles[uid]={el:tile,video,avatar,badge,micDot};
  // Hide avatar automatically when video starts playing
  video.addEventListener('loadedmetadata', ()=>{
    try{ video.play().catch(()=>{}); }catch(e){}
    if(tiles[uid] && tiles[uid].avatar) tiles[uid].avatar.style.display = 'none';
  });
  // If the stream is removed or video has no tracks, show avatar again
  video.addEventListener('emptied', ()=>{ if(tiles[uid] && tiles[uid].avatar) tiles[uid].avatar.style.display = ''; });
  relayout();
  return tiles[uid];
}

function requestPermissions(){
  if (!username || !uid) {
    alert('Chưa tải thông tin người dùng');
    return;
  }
  
  navigator.mediaDevices.getUserMedia({video:true,audio:{echoCancellation:true,noiseSuppression:true}}).then(stream=>{
    console.log('✓ Đã cấp quyền camera & mic');
    localStream=stream; 
    localCamEnabled=true; 
    localMicEnabled=true;
    
    tiles['me']=createTile('me', username);
    tiles['me'].video.srcObject=localStream;
    // Mute local playback so you don't hear your own microphone (self-monitoring)
    try{ tiles['me'].video.muted = true; tiles['me'].video.volume = 0; tiles['me'].avatar.style.display = 'none'; }catch(_){ }
    
    // Remove dim and no-perm classes
    camBtn.classList.remove('dim','no-perm');
    muteBtn.classList.remove('dim','no-perm');
    camBtn.classList.add('mic-active');
    muteBtn.classList.add('mic-active');
    
    startMicAnalyzer('me',localStream);
    joinRoom();
  }).catch(e=>{
    console.error('✗ getUserMedia error:', e);
    if(e.name==="NotAllowedError" || e.name === "PermissionDeniedError"){ 
      camBtn.classList.add('no-perm'); 
      muteBtn.classList.add('no-perm'); 
      alert("Vui lòng cấp quyền Camera & Microphone trong cài đặt trình duyệt!"); 
    } else {
      alert("Lỗi truy cập camera/mic: " + e.message);
    }
  });
}

muteBtn.onclick = ()=>{ 
  if(!localStream) { 
    console.warn('No local stream yet'); 
    return; 
  } 
  localMicEnabled = !localMicEnabled; 
  localStream.getAudioTracks().forEach(t => t.enabled = localMicEnabled);
  muteBtn.classList.toggle('mic-active', localMicEnabled);
};

camBtn.onclick = ()=>{ 
  if(!localStream) { 
    console.warn('No local stream yet'); 
    return; 
  } 
  localCamEnabled = !localCamEnabled; 
  localStream.getVideoTracks().forEach(t => t.enabled = localCamEnabled);
  camBtn.classList.toggle('dim', !localCamEnabled);
};

leaveBtn.onclick = async ()=>{ 
  Object.values(pcs).forEach(pc=>pc.close()); 
  if (uid) {
    try {
      await remove(ref(db, `rooms/${roomId}/participants/${uid}`));
    } catch(e) {
      console.error('Error removing participant:', e);
    }
  }
  location.href="index.html"; 
};

requestPermBtn.onclick = ()=>{
  if (!uid) {
    console.error('uid not yet loaded');
    alert('Đang tải thông tin người dùng, vui lòng chờ...');
    return;
  }
  requestPermissions();
};

inviteBtn.onclick=()=>{ invitePopup.classList.remove('hidden'); loadFriends(); };
closeInvite.onclick=()=>{ invitePopup.classList.add('hidden'); }

async function loadFriends(){
  friendListDiv.innerHTML='<div style="color:#ccc;padding:10px;">Đang tải...</div>';
  try {
    // Load current user's friends list
    const myFriendsSnap = await get(ref(db, `users/${uid}/friends`));
    const myFriends = myFriendsSnap.val() || {};
    const friendIds = Object.keys(myFriends);
    
    if(friendIds.length === 0){
      friendListDiv.innerHTML='<div style="color:#ccc;padding:10px;">Bạn chưa có bạn bè nào</div>';
      return;
    }
    
    // Load friend details from users node
    const usersSnap = await get(ref(db, 'users'));
    const allUsers = usersSnap.val() || {};
    friendListDiv.innerHTML='';
    
    friendIds.forEach(fid=>{
      const f = allUsers[fid];
      if(!f) return; // Skip if friend data not found
      
      const item = elt('div',{class:'item'});
      const avatar = elt('div',{class:'friendAvatar'}, (f.displayName || f.username || 'U')[0].toUpperCase());
      const name = elt('div',{}, f.displayName || f.username);
      const btn = elt('button',{class:'inviteBtn'},'Mời');
      btn.onclick = async ()=>{
        const inviteKey = 'i_'+Math.random().toString(36).slice(2,9);
        await push(ref(db, `invites/${fid}`), {from: uid, fromName: displayName, room: roomId, time: Date.now()});
        btn.classList.add('sent'); btn.innerText='Đã gửi'; btn.disabled=true;
      };
      item.appendChild(avatar); item.appendChild(name); item.appendChild(btn);
      friendListDiv.appendChild(item);
    });
  } catch(e) {
    console.error('loadFriends error:', e);
    friendListDiv.innerHTML='<div style="color:#f44;">Lỗi tải danh sách bạn</div>';
  }
}

function joinRoom(){
  const participantsRef = ref(db, 'rooms/'+roomId+'/participants');
  const signalsRef = ref(db, 'rooms/'+roomId+'/signals');
  
  set(ref(db, `rooms/${roomId}/participants/${uid}`), {name: displayName || username});
  
  onValue(participantsRef, snap=>{
    const data = snap.val()||{};
    Object.keys(data).forEach(pid=>{
      if(pid===uid) return;
      if(!pcs[pid]) createPeer(pid, data[pid].name);
    });
    Object.keys(tiles).forEach(tid=>{
      if(tid!=='me' && !data[tid]){ tiles[tid].el.remove(); delete tiles[tid]; pcs[tid]?.close(); delete pcs[tid]; }
    });
  });

  onValue(signalsRef, snap=>{
    const signals = snap.val();
    if (!signals) return;
    Object.entries(signals).forEach(([key, s]) => {
      if(!s || s.to !== uid) return;
      handleSignal(s.from, s.type, s.data);
      remove(ref(db, `rooms/${roomId}/signals/${key}`));
    });
  });
}

function createPeer(pid, name){
  const pc = new RTCPeerConnection();
  pcs[pid]=pc;
  tiles[pid]=createTile(pid, name);
  if(localStream) localStream.getTracks().forEach(t=>pc.addTrack(t, localStream));
  if(localStream) {
    console.debug('Adding local tracks to PC for', pid, localStream.getTracks().map(t=>t.kind));
    localStream.getTracks().forEach(t=>pc.addTrack(t, localStream));
  } else {
    console.debug('No localStream yet when creating PC for', pid);
  }
  pc.ontrack = e=>{
    console.debug('ontrack from', pid, 'streams:', e.streams);
    tiles[pid].video.srcObject = e.streams[0];
    try{ tiles[pid].avatar.style.display = 'none'; }catch(_){ }
    startMicAnalyzer(pid, e.streams[0]);
  };
  pc.onicecandidate = e=>{
    console.debug('onicecandidate for', pid, e.candidate);
    if(e.candidate) push(ref(db, `rooms/${roomId}/signals`), {from: uid, to: pid, type: 'candidate', data: e.candidate.toJSON()});
  };
  pc.oniceconnectionstatechange = ()=>{ console.debug('ICE connection state for', pid, pc.iceConnectionState); };
  pc.onconnectionstatechange = ()=>{ console.debug('Connection state for', pid, pc.connectionState); };
  pc.ontrack = e=>{ tiles[pid].video.srcObject = e.streams[0]; startMicAnalyzer(pid, e.streams[0]); };
  pc.ontrack = e=>{ 
    tiles[pid].video.srcObject = e.streams[0]; 
    try{ tiles[pid].avatar.style.display = 'none'; }catch(_){ }
    startMicAnalyzer(pid, e.streams[0]); 
  };
  pc.onicecandidate = e=>{ if(e.candidate) push(ref(db, `rooms/${roomId}/signals`), {from: uid, to: pid, type: 'candidate', data: e.candidate.toJSON()}); };
  pc.createOffer().then(o=>{
    pc.setLocalDescription(o);
    push(ref(db, `rooms/${roomId}/signals`), {from: uid, to: pid, type: 'offer', data: o.toJSON()});
  });
}

function handleSignal(from, type, data){
  let pc = pcs[from]; 
  if(!pc){ 
    // Create peer if we haven't yet; we need the name, so try to get it from tiles or default
    const peerName = tiles[from]?.badge?.innerText || 'Peer';
    createPeer(from, peerName); 
    pc = pcs[from]; 
  }
  if(type === 'offer'){ 
    pc.setRemoteDescription(new RTCSessionDescription(data)).then(()=>{ 
      pc.createAnswer().then(a=>{ 
        pc.setLocalDescription(a); 
        push(ref(db, `rooms/${roomId}/signals`), {from: uid, to: from, type: 'answer', data: a.toJSON()}); 
      }); 
    }); 
  }
  else if(type === 'answer'){ 
    pc.setRemoteDescription(new RTCSessionDescription(data)); 
  }
  else if(type === 'candidate'){ 
    pc.addIceCandidate(new RTCIceCandidate(data)); 
  }
}

function startMicAnalyzer(pid,stream){
  const audioCtx = new AudioContext();
  const source = audioCtx.createMediaStreamSource(stream);
  const analyser = audioCtx.createAnalyser();
  analyser.fftSize = 512;
  source.connect(analyser);
  const data = new Uint8Array(analyser.frequencyBinCount);
  audioAnalyzers[pid]=analyser;
  function tick(){ analyser.getByteFrequencyData(data); const vol = data.reduce((a,b)=>a+b,0)/data.length; if(tiles[pid]) tiles[pid].micDot.classList.toggle('micOn',vol>30); requestAnimationFrame(tick); }
  tick();
}
</script>
</body>
</html>
