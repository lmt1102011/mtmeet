<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>MTMET — Video Call PRO</title>
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='16' fill='%2312192a'/%3E%3Ctext x='50'%20y='58' font-size='52' text-anchor='middle' fill='%23ffffff' font-family='Arial'%3EM%3C/text%3E%3C/svg%3E">
<style>
:root{--bg:#0b1b2b;--surface:#12161a;--accent:#2196f3;--muted:#9fb0bd;--text:#e8eaed;--danger:#b71c1c;--tile-radius:14px}
body{margin:0;height:100vh;background:var(--bg);color:var(--text);font-family:Inter,Segoe UI,Arial;display:flex;flex-direction:column}
header{display:flex;align-items:center;gap:12px;padding:12px 18px;background:linear-gradient(90deg,rgba(33,150,243,0.06),transparent);border-bottom:1px solid rgba(255,255,255,0.03)}
.logo{width:44px;height:44px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#64b5f6);display:flex;align-items:center;justify-content:center;font-weight:700}
.header-right{margin-left:auto;display:flex;gap:8px;align-items:center}
#roomTitle{font-weight:700}
#meInfo{font-size:13px;color:var(--muted)}
#inviteBtn{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--accent);padding:8px;border-radius:8px;cursor:pointer}
#stageWrap{flex:1;overflow:auto;padding:16px}
#stage{display:grid;gap:12px;align-content:start}
.tile{background:#000;border-radius:var(--tile-radius);overflow:hidden;position:relative;min-height:150px;display:flex;align-items:center;justify-content:center}
.tile video{width:100%;height:100%;object-fit:cover;display:block}
.tile .avatar{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:48px;font-weight:700;background:linear-gradient(135deg,#263238,#37474f);color:#fff}
.tile .bottomBar{position:absolute;left:12px;right:12px;bottom:12px;display:flex;align-items:center;justify-content:space-between;gap:8px}
.badge{background:rgba(0,0,0,0.45);padding:6px 10px;border-radius:10px;font-weight:600;color:var(--text)}
.micDot{width:10px;height:10px;border-radius:50%;background:#6b6b6b;margin-left:8px;box-shadow:0 0 0 0 rgba(0,0,0,0)}
.micOn{background:#00e676;box-shadow:0 0 8px rgba(0,230,118,0.18)}
.controls{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:var(--surface);padding:12px 14px;border-radius:40px;display:flex;gap:10px;box-shadow:0 10px 60px rgba(0,0,0,0.6);z-index:40}
.controlBtn{width:56px;height:56px;border-radius:50%;border:none;background:var(--accent);color:#fff;cursor:pointer;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:14px}
.controlBtn.dim{filter:grayscale(60%) brightness(0.6)}
.controlBtn.danger{background:var(--danger)}
.controlBtn.no-perm{background:#4e1a1a}
.controlBtn.mic-active{box-shadow:0 0 18px rgba(0,230,118,0.22);}
/* Popup invite */
.popup{position:fixed;inset:0;background:rgba(0,0,0,0.55);display:flex;align-items:center;justify-content:center;z-index:999}
.popup.hidden{display:none}
.popupContent{width:360px;max-height:75vh;background:var(--surface);border-radius:14px;overflow:auto;padding:14px;box-shadow:0 0 40px rgba(0,0,0,0.4)}
.popupHeader{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;font-size:18px;font-weight:600}
.closeBtn{border:none;background:transparent;color:var(--muted);font-size:18px;cursor:pointer}
.friendList .item{display:flex;align-items:center;justify-content:space-between;padding:10px;border-radius:10px;background:rgba(255,255,255,0.02);margin-bottom:8px}
.friendAvatar{width:40px;height:40px;background:linear-gradient(135deg,#455a64,#607d8b);border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:18px}
.inviteBtn{padding:6px 10px;border-radius:8px;border:none;cursor:pointer;background:var(--accent);color:#fff}
.inviteBtn.sent{background:#4e1a1a;cursor:not-allowed}
@media (min-width:1400px){#stage{grid-template-columns:repeat(4,1fr)}}
@media (max-width:1399px) and (min-width:900px){#stage{grid-template-columns:repeat(3,1fr)}}
@media (max-width:899px) and (min-width:600px){#stage{grid-template-columns:repeat(2,1fr)}}
@media (max-width:599px){#stage{grid-template-columns:repeat(1,1fr)}}
.small{font-size:13px;color:var(--muted)}
.hidden{display:none}
</style>
</head>
<body>

<header>
  <div class="logo">M</div>
  <div>
    <div id="roomTitle">Room</div>
    <div id="meInfo" class="small">...</div>
  </div>
  <div class="header-right">
    <div id="meName" class="small"></div>
    <button id="inviteBtn">Invite</button>
  </div>
</header>

<div id="stageWrap"><div id="stage"></div></div>

<!-- On-screen debug panel -->
<div id="debugPanel" style="position:fixed;right:12px;bottom:90px;width:320px;max-height:350px;background:rgba(0,0,0,0.85);border:2px solid #00ff00;padding:10px;border-radius:8px;color:#00ff00;font-family:monospace;font-size:11px;z-index:9999;overflow:hidden;display:flex;flex-direction:column">
  <div style="display:flex;justify-content:space-between;margin-bottom:8px;font-weight:bold">
    <span>DEBUG LOG</span>
    <button id="dbgClear" style="background:transparent;border:1px solid #00ff00;color:#00ff00;padding:2px 6px;border-radius:4px;cursor:pointer;font-size:10px">Clear</button>
  </div>
  <div id="dbgContent" style="overflow-y:auto;flex:1;white-space:pre-wrap;word-wrap:break-word;line-height:1.4"></div>
</div>

<div class="controls">
  <button id="requestPermBtn" class="controlBtn" title="Enable Camera & Mic">SET</button>
  <button id="muteBtn" class="controlBtn dim" title="Toggle mic">MIC</button>
  <button id="camBtn" class="controlBtn dim" title="Toggle cam">CAM</button>
  <button id="leaveBtn" class="controlBtn danger" title="Leave">✖</button>
</div>

<!-- Invite Popup -->
<div id="invitePopup" class="popup hidden">
  <div class="popupContent">
    <div class="popupHeader">
      <div>Chọn bạn để mời</div>
      <button id="closeInvite" class="closeBtn">✖</button>
    </div>
    <div id="friendList" class="friendList"></div>
  </div>
</div>

<script src="firebase-config.js"></script>
<script type="module">
import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js';
import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-auth.js';
import { getDatabase, ref, set, onValue, push, get, remove } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-database.js';

const app = initializeApp(window.FIREBASE_CONFIG);
const auth = getAuth(app);
const db = getDatabase(app);

console.debug('call.html loaded with DB URL:', window.FIREBASE_CONFIG && window.FIREBASE_CONFIG.databaseURL);

// Debug helpers - log to on-screen panel
let dbgLog = [];
const dbgContent = document.getElementById('dbgContent');
const dbgClear = document.getElementById('dbgClear');
function dbg(msg){
  const ts = new Date().toLocaleTimeString();
  const line = `[${ts}] ${msg}`;
  dbgLog.push(line);
  if(dbgLog.length > 60) dbgLog.shift();
  if(dbgContent) dbgContent.innerText = dbgLog.join('\n');
  console.debug(line);
}
if(dbgClear) dbgClear.onclick = ()=>{ dbgLog = []; if(dbgContent) dbgContent.innerText = ''; };
dbg('=== DEBUG PANEL ACTIVE ===');

// Check auth state and wait for user data to load
let authReadyPromise = new Promise((resolve) => {
  onAuthStateChanged(auth, async user => {
    if (!user) {
      location.href = 'login.html';
      return;
    }
    window.currentUser = { uid: user.uid };
    console.debug('call.html auth user:', user.uid);
    
    // Load user display name from DB
    try {
      const userSnap = await get(ref(db, `users/${user.uid}`));
      const userData = userSnap.val();
      if (userData) {
        window.currentUser.displayName = userData.displayName;
        window.currentUser.username = userData.username;
        console.debug('call.html user data loaded:', window.currentUser);
      } else {
        console.warn('User data not found for:', user.uid);
      }
    } catch (e) {
      console.error('Error loading user data:', e);
    }
    resolve(window.currentUser);
  });
});


const stage = document.getElementById('stage');
const meInfo = document.getElementById('meInfo');
const meName = document.getElementById('meName');
const inviteBtn = document.getElementById('inviteBtn');
const requestPermBtn = document.getElementById('requestPermBtn');
const muteBtn = document.getElementById('muteBtn');
const camBtn = document.getElementById('camBtn');
const leaveBtn = document.getElementById('leaveBtn');
const invitePopup = document.getElementById('invitePopup');
const friendListDiv = document.getElementById('friendList');
const closeInvite = document.getElementById('closeInvite');

let roomId = new URLSearchParams(location.search).get('room') || "demo-room";

// Will be filled from Firebase auth (via Promise)
let uid = null;
let username = null;
let displayName = null;

// Wait for auth to be ready
authReadyPromise.then(() => {
  const user = window.currentUser;
  uid = user.uid;
  username = user.username;
  displayName = user.displayName || user.username;
  
  console.debug('Auth ready - uid:', uid, 'username:', username, 'displayName:', displayName);
  
  meName.innerText = displayName;
  meInfo.innerText = uid;
  
  // Auto-request media permissions when auth is ready
  dbg('Auth ready. Auto-requesting media permissions...');
  requestPermissions();
}).catch(err => {
  console.error('Failed to load auth:', err);
  alert('Lỗi tải thông tin người dùng');
});

let localStream=null;
let localMicEnabled=false;
let localCamEnabled=false;
let pcs = {};
let tiles = {};
let audioAnalyzers = {};

function elt(t,attrs={},txt=''){ const e=document.createElement(t); for(const k in attrs) e.setAttribute(k,attrs[k]); if(txt) e.innerText=txt; return e; }
function relayout(){ const count=Object.keys(tiles).length||1; const w=stage.clientWidth; let cols=1; if(w>=1400) cols=Math.min(4,count); else if(w>=900) cols=Math.min(3,count); else if(w>=600) cols=Math.min(2,count); else cols=1; stage.style.gridTemplateColumns=`repeat(${cols},1fr)`;}
window.addEventListener('resize',relayout);

function createTile(uid,name){
  if(tiles[uid]) return tiles[uid];
  const tile = elt('div',{class:'tile'});
  const video = elt('video',{autoplay:true,playsinline:true});
  const safeName = (name && String(name).trim()) ? String(name).trim() : 'U';
  const avatarInitial = (safeName && safeName[0]) ? safeName[0].toUpperCase() : 'U';
  const avatar = elt('div',{class:'avatar'},avatarInitial);
  const bottomBar = elt('div',{class:'bottomBar'});
  const badge = elt('div',{class:'badge'},name);
  const micDot = elt('div',{class:'micDot'});
  bottomBar.appendChild(badge); bottomBar.appendChild(micDot);
  tile.appendChild(video); tile.appendChild(avatar); tile.appendChild(bottomBar);
  stage.appendChild(tile);
  tiles[uid]={el:tile,video,avatar,badge,micDot};
  // Hide avatar automatically when video starts playing
  video.addEventListener('loadedmetadata', ()=>{
    try{ video.play().catch(()=>{}); }catch(e){}
    if(tiles[uid] && tiles[uid].avatar) tiles[uid].avatar.style.display = 'none';
  });
  // If the stream is removed or video has no tracks, show avatar again
  video.addEventListener('emptied', ()=>{ if(tiles[uid] && tiles[uid].avatar) tiles[uid].avatar.style.display = ''; });
  relayout();
  return tiles[uid];
}

async function requestPermissions(){
  if (!username || !uid) {
    alert('Chưa tải thông tin người dùng');
    return;
  }
  
  // Try to get media with graceful fallback
  let stream = null;
  let mediaType = null;
  
  // Try 1: video + audio
  try {
    dbg('Attempting: video + audio...');
    stream = await navigator.mediaDevices.getUserMedia({video:true,audio:{echoCancellation:true,noiseSuppression:true}});
    mediaType = 'video+audio';
    dbg('✓ getUserMedia success - camera & mic granted');
  } catch(e1) {
    dbg(`✗ video+audio failed (${e1.name}), trying audio-only...`);
    // Try 2: audio only
    try {
      stream = await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:true,noiseSuppression:true}});
      mediaType = 'audio';
      dbg('✓ getUserMedia success - mic granted (no camera)');
    } catch(e2) {
      dbg(`✗ audio-only failed (${e2.name}), trying video-only...`);
      // Try 3: video only
      try {
        stream = await navigator.mediaDevices.getUserMedia({video:true});
        mediaType = 'video';
        dbg('✓ getUserMedia success - camera granted (no mic)');
      } catch(e3) {
        dbg(`✗ video-only failed (${e3.name}). Joining room without local stream.`);
        console.error('All media requests failed:', e1, e2, e3);
        camBtn.classList.add('no-perm'); 
        muteBtn.classList.add('no-perm');
        joinRoom(); // Join without local stream
        return;
      }
    }
  }

  if (!stream) {
    dbg('No stream obtained. Joining room without local stream.');
    joinRoom();
    return;
  }

  localStream = stream;
  localCamEnabled = (mediaType === 'video+audio' || mediaType === 'video');
  localMicEnabled = (mediaType === 'video+audio' || mediaType === 'audio');
  
  console.log(`✓ Đã cấp quyền (${mediaType})`);
  
  tiles['me']=createTile('me', username);
  tiles['me'].video.srcObject=localStream;
  // Mute local playback so you don't hear your own microphone (self-monitoring)
  try{ tiles['me'].video.muted = true; tiles['me'].video.volume = 0; tiles['me'].avatar.style.display = 'none'; }catch(_){ }
  
  // Remove dim and no-perm classes if we have media
  if(localCamEnabled) { camBtn.classList.remove('dim','no-perm'); camBtn.classList.add('mic-active'); }
  if(localMicEnabled) { muteBtn.classList.remove('dim','no-perm'); muteBtn.classList.add('mic-active'); }
  
  if(localMicEnabled) startMicAnalyzer('me',localStream);
  joinRoom();
}

muteBtn.onclick = ()=>{ 
  if(!localStream) { 
    console.warn('No local stream yet'); 
    return; 
  } 
  localMicEnabled = !localMicEnabled; 
  localStream.getAudioTracks().forEach(t => t.enabled = localMicEnabled);
  muteBtn.classList.toggle('mic-active', localMicEnabled);
};

camBtn.onclick = ()=>{ 
  if(!localStream) { 
    console.warn('No local stream yet'); 
    return; 
  } 
  localCamEnabled = !localCamEnabled; 
  localStream.getVideoTracks().forEach(t => t.enabled = localCamEnabled);
  camBtn.classList.toggle('dim', !localCamEnabled);
};

leaveBtn.onclick = async ()=>{ 
  Object.values(pcs).forEach(pc=>pc.close()); 
  if (uid) {
    try {
      await remove(ref(db, `rooms/${roomId}/participants/${uid}`));
    } catch(e) {
      console.error('Error removing participant:', e);
    }
  }
  location.href="index.html"; 
};

requestPermBtn.onclick = ()=>{
  if (!uid) {
    console.error('uid not yet loaded');
    alert('Đang tải thông tin người dùng, vui lòng chờ...');
    return;
  }
  requestPermissions();
};

inviteBtn.onclick=()=>{ invitePopup.classList.remove('hidden'); loadFriends(); };
closeInvite.onclick=()=>{ invitePopup.classList.add('hidden'); }

async function loadFriends(){
  friendListDiv.innerHTML='<div style="color:#ccc;padding:10px;">Đang tải...</div>';
  try {
    // Load current user's friends list
    const myFriendsSnap = await get(ref(db, `users/${uid}/friends`));
    const myFriends = myFriendsSnap.val() || {};
    const friendIds = Object.keys(myFriends);
    
    if(friendIds.length === 0){
      friendListDiv.innerHTML='<div style="color:#ccc;padding:10px;">Bạn chưa có bạn bè nào</div>';
      return;
    }
    
    // Load friend details from users node
    const usersSnap = await get(ref(db, 'users'));
    const allUsers = usersSnap.val() || {};
    friendListDiv.innerHTML='';
    
    friendIds.forEach(fid=>{
      const f = allUsers[fid];
      if(!f) return; // Skip if friend data not found
      
      const item = elt('div',{class:'item'});
      const avatar = elt('div',{class:'friendAvatar'}, (f.displayName || f.username || 'U')[0].toUpperCase());
      const name = elt('div',{}, f.displayName || f.username);
      const btn = elt('button',{class:'inviteBtn'},'Mời');
      btn.onclick = async ()=>{
        const inviteKey = 'i_'+Math.random().toString(36).slice(2,9);
        await push(ref(db, `invites/${fid}`), {from: uid, fromName: displayName, room: roomId, time: Date.now()});
        btn.classList.add('sent'); btn.innerText='Đã gửi'; btn.disabled=true;
      };
      item.appendChild(avatar); item.appendChild(name); item.appendChild(btn);
      friendListDiv.appendChild(item);
    });
  } catch(e) {
    console.error('loadFriends error:', e);
    friendListDiv.innerHTML='<div style="color:#f44;">Lỗi tải danh sách bạn</div>';
  }
}

let participantsUnsubscribe = null;
let signalsUnsubscribe = null;

function joinRoom(){
  const participantsRef = ref(db, 'rooms/'+roomId+'/participants');
  const signalsRef = ref(db, 'rooms/'+roomId+'/signals');
  
  dbg(`Joining room: ${roomId}`);
  
  // Unsubscribe from old listeners if any (avoid duplicate listeners when re-joining)
  if(participantsUnsubscribe) participantsUnsubscribe();
  if(signalsUnsubscribe) signalsUnsubscribe();
  
  set(ref(db, `rooms/${roomId}/participants/${uid}`), {name: displayName || username});
  
  participantsUnsubscribe = onValue(participantsRef, snap=>{
    const data = snap.val()||{};
    dbg(`Participants: ${Object.keys(data).join(', ')}`);
    Object.keys(data).forEach(pid=>{
      if(pid===uid) return;
      if(!pcs[pid]){ dbg(`Creating peer for ${pid}`); createPeer(pid, data[pid].name); }
    });
    Object.keys(tiles).forEach(tid=>{
      if(tid!=='me' && !data[tid]){ dbg(`Removing tile for ${tid}`); tiles[tid].el.remove(); delete tiles[tid]; pcs[tid]?.close(); delete pcs[tid]; }
    });
  });

  signalsUnsubscribe = onValue(signalsRef, snap=>{
    const signals = snap.val();
    if (!signals) return;
    Object.entries(signals).forEach(([key, s]) => {
      if(!s || s.to !== uid) return;
      dbg(`Signal from ${s.from}: ${s.type}`);
      handleSignal(s.from, s.type, s.data);
      remove(ref(db, `rooms/${roomId}/signals/${key}`));
    });
  });
}

function createPeer(pid, name){
  const pc = new RTCPeerConnection();
  pcs[pid]=pc;
  tiles[pid]=createTile(pid, name);
  iceCandidateBuffer[pid] = []; // initialize buffer for this peer
  
  if(localStream) {
    dbg(`Adding ${localStream.getTracks().length} local tracks to PC for ${pid}`);
    localStream.getTracks().forEach(t=>pc.addTrack(t, localStream));
  } else {
    dbg(`No localStream yet when creating PC for ${pid}`);
  }
  pc.ontrack = e=>{
    dbg(`ontrack from ${pid}: ${e.streams.length} streams, track kind=${e.track.kind}, enabled=${e.track.enabled}`);
    if(tiles[pid]) {
      dbg(`Setting video.srcObject for ${pid}`);
      tiles[pid].video.srcObject = e.streams[0];
      try{ tiles[pid].avatar.style.display = 'none'; }catch(_){ }
      if(e.track.kind === 'audio') startMicAnalyzer(pid, e.streams[0]);
    } else {
      dbg(`ERROR: tile not found for ${pid}`);
    }
  };
  pc.onicecandidate = e=>{
    if(e.candidate) { 
      dbg(`ICE candidate for ${pid}: ${e.candidate.candidate ? e.candidate.candidate.slice(0,50) : '(empty)'}`);
      // Send the full RTCIceCandidate object, not just toJSON()
      const candData = {
        candidate: e.candidate.candidate,
        sdpMLineIndex: e.candidate.sdpMLineIndex,
        sdpMid: e.candidate.sdpMid
      };
      push(ref(db, `rooms/${roomId}/signals`), {from: uid, to: pid, type: 'candidate', data: candData}); 
    }
  };
  pc.oniceconnectionstatechange = ()=>{ dbg(`ICE state ${pid}: ${pc.iceConnectionState}`); };
  pc.onconnectionstatechange = ()=>{ dbg(`Connection state ${pid}: ${pc.connectionState}`); };
  pc.onerror = e=>{ dbg(`PC error for ${pid}: ${e}`); };
  
  // Offer-answer negotiation: only the peer with smaller UID creates offer
  // This avoids race conditions where both peers try to create offers simultaneously
  const shouldCreateOffer = uid < pid;
  
  if(shouldCreateOffer) {
    dbg(`I have smaller UID (${uid} < ${pid}), creating offer...`);
    pc.createOffer().then(o=>{
      dbg(`Sending offer to ${pid}`);
      pc.setLocalDescription(o);
      push(ref(db, `rooms/${roomId}/signals`), {from: uid, to: pid, type: 'offer', data: o});
    }).catch(err=>{ dbg(`Error creating offer for ${pid}: ${err.message}`); });
  } else {
    dbg(`I have larger UID (${uid} > ${pid}), waiting for offer...`);
  }
}

function handleSignal(from, type, data){
  let pc = pcs[from]; 
  if(!pc){ 
    dbg(`PC not found for ${from}, creating...`);
    const peerName = tiles[from]?.badge?.innerText || 'Peer';
    createPeer(from, peerName); 
    pc = pcs[from]; 
  }
  if(type === 'offer'){ 
    dbg(`Handling offer from ${from}`);
    pc.setRemoteDescription(new RTCSessionDescription(data)).then(()=>{ 
      dbg(`Remote description (offer) set for ${from}. Flushing buffered ICE candidates...`);
      // Flush buffered candidates
      if(iceCandidateBuffer[from]) {
        iceCandidateBuffer[from].forEach(cand=>{
          pc.addIceCandidate(new RTCIceCandidate(cand)).catch(err=>{ dbg(`Error adding buffered ICE candidate from ${from}: ${err.message}`); });
        });
        iceCandidateBuffer[from] = [];
      }
      // Only the peer with larger UID creates answer
      if(uid > from) {
        dbg(`I have larger UID (${uid} > ${from}), creating answer...`);
        pc.createAnswer().then(a=>{ 
          dbg(`Sending answer to ${from}`);
          pc.setLocalDescription(a); 
          push(ref(db, `rooms/${roomId}/signals`), {from: uid, to: from, type: 'answer', data: a}); 
        }).catch(err=>{ dbg(`Error creating answer for ${from}: ${err.message}`); }); 
      } else {
        dbg(`I have smaller UID (${uid} < ${from}), NOT creating answer (peer will)`);
      }
    }).catch(err=>{ dbg(`Error setting remote description (offer) from ${from}: ${err.message}`); }); 
  }
  else if(type === 'answer'){ 
    dbg(`Handling answer from ${from}`);
    pc.setRemoteDescription(new RTCSessionDescription(data)).then(()=>{
      dbg(`Remote description (answer) set for ${from}. Flushing buffered ICE candidates...`);
      // Flush buffered candidates
      if(iceCandidateBuffer[from]) {
        iceCandidateBuffer[from].forEach(cand=>{
          pc.addIceCandidate(new RTCIceCandidate(cand)).catch(err=>{ dbg(`Error adding buffered ICE candidate from ${from}: ${err.message}`); });
        });
        iceCandidateBuffer[from] = [];
      }
    }).catch(err=>{ dbg(`Error setting remote description (answer) from ${from}: ${err.message}`); });
  }
  else if(type === 'candidate'){ 
    dbg(`Received ICE candidate from ${from}`);
    // If remote description is not set yet, buffer the candidate
    if(!pc.remoteDescription) {
      dbg(`Buffering ICE candidate from ${from} (remote description not set yet)`);
      if(!iceCandidateBuffer[from]) iceCandidateBuffer[from] = [];
      iceCandidateBuffer[from].push(data);
    } else {
      dbg(`Adding ICE candidate from ${from}`);
      try {
        pc.addIceCandidate(new RTCIceCandidate(data));
      } catch(err) { 
        dbg(`Error adding ICE candidate from ${from}: ${err.message}`); 
      }
    }
  }
}

function startMicAnalyzer(pid,stream){
  const audioCtx = new AudioContext();
  const source = audioCtx.createMediaStreamSource(stream);
  const analyser = audioCtx.createAnalyser();
  analyser.fftSize = 512;
  source.connect(analyser);
  const data = new Uint8Array(analyser.frequencyBinCount);
  audioAnalyzers[pid]=analyser;
  function tick(){ analyser.getByteFrequencyData(data); const vol = data.reduce((a,b)=>a+b,0)/data.length; if(tiles[pid]) tiles[pid].micDot.classList.toggle('micOn',vol>30); requestAnimationFrame(tick); }
  tick();
}
</script>
</body>
</html>
