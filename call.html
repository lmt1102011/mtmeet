<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>MTMET — Call (Permissions + VAD + Robust UI)</title>
<style>
:root{
  --bg:#0b1b2b; --surface:#12161a; --accent:#2196f3; --muted:#9fb0bd; --text:#e8eaed;
  --danger:#b71c1c; --tile-radius:14px;
}
*{box-sizing:border-box}
body{margin:0;height:100vh;background:var(--bg);color:var(--text);font-family:Inter,Segoe UI,Arial;display:flex;flex-direction:column}
header{display:flex;align-items:center;gap:12px;padding:12px 18px;background:linear-gradient(90deg,rgba(33,150,243,0.06),transparent);border-bottom:1px solid rgba(255,255,255,0.03)}
.logo{width:44px;height:44;border-radius:10px;background:linear-gradient(135deg,var(--accent),#64b5f6);display:flex;align-items:center;justify-content:center;font-weight:700}
.header-right{margin-left:auto;display:flex;gap:8px;align-items:center}
#roomTitle{font-weight:700}
#inviteBtn{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--accent);padding:8px;border-radius:8px;cursor:pointer}
#stageWrap{flex:1;overflow:auto;padding:16px}
#stage{display:grid;gap:12px;align-content:start}

/* tile */
.tile{background:#000;border-radius:var(--tile-radius);overflow:hidden;position:relative;min-height:150px;display:flex;align-items:center;justify-content:center}
.tile video{width:100%;height:100%;object-fit:cover;display:block}
.tile .avatar{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:48px;font-weight:700;background:linear-gradient(135deg,#263238,#37474f);color:#fff}
.tile .bottomBar{position:absolute;left:12px;right:12px;bottom:12px;display:flex;align-items:center;justify-content:space-between;gap:8px}
.badge{background:rgba(0,0,0,0.45);padding:6px 10px;border-radius:10px;font-weight:600}

/* mic indicator small on tile */
.micDot{width:10px;height:10px;border-radius:50%;background:#6b6b6b;margin-left:8px;box-shadow:0 0 0 0 rgba(0,0,0,0)}
.micOn{background:#00e676;box-shadow:0 0 8px rgba(0,230,118,0.18)}

/* Controls */
.controls{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:var(--surface);padding:12px 14px;border-radius:40px;display:flex;gap:10px;box-shadow:0 10px 60px rgba(0,0,0,0.6);z-index:40}
.controlBtn{width:56px;height:56px;border-radius:50%;border:none;background:var(--accent);color:#fff;cursor:pointer;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:14px}
.controlBtn.dim{filter:grayscale(60%) brightness(0.6)}
.controlBtn.danger{background:var(--danger)}
.controlBtn.no-perm{background:#4e1a1a} /* dark red when permission denied */

/* mic glow ring when active audio */
.controlBtn.mic-active{box-shadow:0 0 18px rgba(0,230,118,0.22);}

/* responsive grid */
@media (min-width:1400px){ #stage{grid-template-columns:repeat(4,1fr)} }
@media (max-width:1399px) and (min-width:900px){ #stage{grid-template-columns:repeat(3,1fr)} }
@media (max-width:899px) and (min-width:600px){ #stage{grid-template-columns:repeat(2,1fr)} }
@media (max-width:599px){ #stage{grid-template-columns:repeat(1,1fr)} }

/* small helpers */
.small{font-size:13px;color:var(--muted)}
.hidden{display:none}
</style>
</head>
<body>

<header>
  <div class="logo">M</div>
  <div>
    <div id="roomTitle">Room</div>
    <div id="meInfo" class="small">...</div>
  </div>
  <div class="header-right">
    <div id="meName" class="small"></div>
    <button id="inviteBtn">Invite</button>
  </div>
</header>

<div id="stageWrap"><div id="stage" role="region" aria-live="polite"></div></div>

<div class="controls" role="toolbar" aria-label="call controls">
  <button id="enablePermBtn" class="controlBtn" title="Enable Camera & Mic">⚙️</button>
  <button id="muteBtn" class="controlBtn" title="Toggle mic">MIC</button>
  <button id="camBtn" class="controlBtn" title="Toggle cam">CAM</button>
  <!-- share removed per request -->
  <button id="leaveBtn" class="controlBtn danger" title="Leave">✖</button>
</div>

<script src="firebase-config.js"></script>
<script type="module">
import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js';
import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-auth.js';
import {
  getDatabase, ref, set, push, onValue, onChildAdded, remove, onDisconnect, get
} from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-database.js';

const app = initializeApp(window.FIREBASE_CONFIG);
const auth = getAuth(app);
const db = getDatabase(app);

const stage = document.getElementById('stage');
const roomTitle = document.getElementById('roomTitle');
const meInfo = document.getElementById('meInfo');
const meName = document.getElementById('meName');
const inviteBtn = document.getElementById('inviteBtn');

const enablePermBtn = document.getElementById('enablePermBtn');
const muteBtn = document.getElementById('muteBtn');
const camBtn = document.getElementById('camBtn');
const leaveBtn = document.getElementById('leaveBtn');

let roomId = new URL(location.href).searchParams.get('room');
let me = null;
let localStream = null;
let localCamEnabled = false;
let localMicEnabled = false;
let permissionDeniedCam = false;
let permissionDeniedMic = false;

let pcs = {}; // peerUid -> RTCPeerConnection
let tiles = {}; // uid -> {el, video, avatar, micDot, badge}
let vadIntervals = {}; // uid -> interval request
const iceServers = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

// helpers
const elt = (t, attrs={}, txt='') => { const e=document.createElement(t); for(const k in attrs) e.setAttribute(k, attrs[k]); if(txt) e.innerText = txt; return e; };

// adjust grid
function relayout(){ const count = Object.keys(tiles).length || 1; const w = stage.clientWidth; let cols=1; if(w>=1400) cols=Math.min(4,count); else if(w>=900) cols=Math.min(3,count); else if(w>=600) cols=Math.min(2,count); else cols=1; stage.style.gridTemplateColumns = `repeat(${cols},1fr)`; }
window.addEventListener('resize', relayout);

// ensure tile present
function ensureTile(uid, name){
  if(tiles[uid]) return tiles[uid];
  const t = elt('div',{class:'tile', id:'tile_'+uid});
  const v = document.createElement('video'); v.autoplay=true; v.playsInline=true; v.muted = (uid===me.uid);
  v.style.display = 'none'; // default hidden until cam true
  const av = elt('div',{class:'avatar'}, (name && name[0])?name[0].toUpperCase():'?');
  const bottom = elt('div',{class:'bottomBar'});
  const badge = elt('div',{class:'badge'}, name || uid);
  const right = elt('div',{});
  const micDot = elt('div',{class:'micDot'});
  right.appendChild(micDot);
  bottom.appendChild(badge); bottom.appendChild(right);

  t.appendChild(v); t.appendChild(av); t.appendChild(bottom);
  stage.appendChild(t);

  tiles[uid] = { el:t, video:v, avatar:av, badge, micDot, name, cam:false, mic:false };
  relayout();
  return tiles[uid];
}

function removeTile(uid){
  if(!tiles[uid]) return;
  try{ tiles[uid].el.remove(); }catch(e){}
  if(vadIntervals[uid]) { cancelAnimationFrame(vadIntervals[uid]); delete vadIntervals[uid]; }
  delete tiles[uid];
  relayout();
}

// VAD for a stream -> animate micDot and mic button glow for local
function startVADFor(uid, stream, isLocal=false){
  try{
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const ctx = new AudioContext();
    const src = ctx.createMediaStreamSource(stream);
    const analyser = ctx.createAnalyser(); analyser.fftSize = 256;
    const data = new Uint8Array(analyser.frequencyBinCount);
    src.connect(analyser);

    function tick(){
      analyser.getByteFrequencyData(data);
      let sum=0; for(let i=0;i<data.length;i++) sum += data[i];
      const avg = sum / data.length;
      const tile = tiles[uid];
      if(tile){
        if(avg > 10){ tile.micDot.classList.add('micOn'); } else { tile.micDot.classList.remove('micOn'); }
      }
      if(isLocal){
        if(avg > 10) muteBtn.classList.add('mic-active'); else muteBtn.classList.remove('mic-active');
      }
      vadIntervals[uid] = requestAnimationFrame(tick);
    }
    tick();
  }catch(e){
    console.warn('VAD failed', e);
  }
}

// try get devices; if denied, set flags
async function tryGetMedia(constraints){
  try{
    const s = await navigator.mediaDevices.getUserMedia(constraints);
    return { ok:true, stream:s };
  }catch(e){
    // handle permission denied or not available
    return { ok:false, error:e };
  }
}

// join room participants node even if no media granted
async function joinRoomNode(){
  const pref = ref(db, `rooms/${roomId}/participants/${me.uid}`);
  await set(pref, { name: me.displayName, cam: !!localCamEnabled, mic: !!localMicEnabled, joinedAt: Date.now() });
  try{ onDisconnect(pref).remove(); } catch(e){ console.warn('onDisconnect not supported', e); }
}

// listen participants and ensure tiles + create offers
function watchParticipants(){
  onValue(ref(db, `rooms/${roomId}/participants`), snapshot=>{
    const val = snapshot.val() || {};
    // ensure tiles for everyone
    Object.entries(val).forEach(([pid, info])=>{
      ensureTile(pid, info.name);
      // update cam/mic indicators and video display depending on info
      const t = tiles[pid];
      if(t){
        t.cam = !!info.cam;
        t.mic = !!info.mic;
        // show avatar or video placeholder based on cam flag
        if(t.cam && t.video.srcObject) {
          t.video.style.display = 'block'; t.avatar.style.display = 'none';
        } else {
          t.video.style.display = 'none'; t.avatar.style.display = 'flex';
        }
        if(info.name) t.badge.innerText = info.name;
        t.micDot.classList.toggle('micOn', !!info.mic);
      }
    });
    // create offers to new participants if we have local stream or even if not we still create peer (we'll add no tracks)
    Object.keys(val).forEach(pid=>{
      if(pid === me.uid) return;
      if(!pcs[pid]) createOffer(pid, val[pid].name);
    });
    // cleanup peers whose participants removed
    Object.keys(pcs).forEach(k=>{ if(!val[k]) closePeer(k); });
    // also remove tiles for those not in participants
    Object.keys(tiles).forEach(k=>{ if(!val[k]) removeTile(k); });
  });
}

// Listen incoming signals (push-based) for myself using onChildAdded
function listenSignalsForMyself(){
  const mySignalsRef = ref(db, `rooms/${roomId}/signals/${me.uid}`);
  onChildAdded(mySignalsRef, async snap=>{
    const key = snap.key; const msg = snap.val();
    if(!msg) return;
    try{ await handleSignal(msg.from, msg); }catch(e){ console.error('handleSignal error', e); }
    // remove message after handle
    try{ await remove(ref(db, `rooms/${roomId}/signals/${me.uid}/${key}`)); }catch(e){}
  });
}

// create peer and send offer (push) - if no localStream we still create pc without tracks
async function createOffer(peerUid, peerName){
  if(pcs[peerUid]) return;
  const pc = new RTCPeerConnection(iceServers);
  pcs[peerUid] = pc;

  ensureTile(peerUid, peerName);

  // add local tracks if present
  if(localStream){
    localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
  }

  pc.ontrack = e=>{
    const stream = e.streams[0];
    const t = ensureTile(peerUid, peerName);
    if(t && t.video.srcObject !== stream){
      t.video.srcObject = stream;
      // if participant's cam flag true, display video; else keep avatar
      if(t.cam) { t.video.style.display = 'block'; t.avatar.style.display='none'; }
      startVADFor(peerUid, stream, false);
    }
  };

  pc.onicecandidate = e=>{
    if(e.candidate){
      push(ref(db, `rooms/${roomId}/signals/${peerUid}`), { from: me.uid, type:'candidate', candidate: e.candidate.toJSON() }).catch(()=>{});
    }
  };

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  await push(ref(db, `rooms/${roomId}/signals/${peerUid}`), { from: me.uid, type:'offer', sdp: offer.sdp, name: me.displayName });
}

// handle incoming messages
async function handleSignal(fromUid, msg){
  if(msg.type === 'offer'){
    if(!pcs[fromUid]){
      const pc = new RTCPeerConnection(iceServers);
      pcs[fromUid] = pc;
      ensureTile(fromUid, msg.name);
      // add local tracks if exists
      if(localStream) localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
      pc.ontrack = e=>{
        const stream = e.streams[0];
        const t = ensureTile(fromUid, msg.name);
        if(t && t.video.srcObject !== stream){
          t.video.srcObject = stream;
          if(t.cam) { t.video.style.display='block'; t.avatar.style.display='none'; }
          startVADFor(fromUid, stream, false);
        }
      };
      pc.onicecandidate = e=>{
        if(e.candidate) push(ref(db, `rooms/${roomId}/signals/${fromUid}`), { from: me.uid, type:'candidate', candidate: e.candidate.toJSON() }).catch(()=>{});
      };
    }
    const pc = pcs[fromUid];
    await pc.setRemoteDescription({ type:'offer', sdp: msg.sdp });
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    await push(ref(db, `rooms/${roomId}/signals/${fromUid}`), { from: me.uid, type:'answer', sdp: answer.sdp });
  } else if(msg.type === 'answer'){
    const pc = pcs[fromUid];
    if(pc) await pc.setRemoteDescription({ type:'answer', sdp: msg.sdp });
  } else if(msg.type === 'candidate'){
    const pc = pcs[fromUid];
    if(pc) try{ await pc.addIceCandidate(new RTCIceCandidate(msg.candidate)); }catch(e){ console.warn(e); }
  }
}

function closePeer(uid){
  if(pcs[uid]) try{ pcs[uid].close(); }catch(e){}
  delete pcs[uid];
  removeTile(uid);
  relayout();
}

// update my participant node cam/mic
async function updateMyPresence(cam, mic){
  try{
    await set(ref(db, `rooms/${roomId}/participants/${me.uid}`), { name: me.displayName, cam: !!cam, mic: !!mic, joinedAt: Date.now() });
    // onDisconnect already set in join
  }catch(e){ console.warn('update presence failed', e); }
}

// enable device permissions (explicit button) - will request both
enablePermBtn.onclick = async ()=>{
  // attempt to get both mic and cam
  const result = await tryGetMedia({ video:true, audio:true });
  if(result.ok){
    // attach stream and update flags
    localStream = result.stream;
    localCamEnabled = true;
    localMicEnabled = true;
    permissionDeniedCam = false; permissionDeniedMic = false;
    // attach local stream to our tile
    const t = ensureTile(me.uid, me.displayName);
    t.video.srcObject = localStream;
    t.video.style.display = 'block'; t.avatar.style.display='none';
    startVADFor(me.uid, localStream, true);
    // update DB presence
    updateMyPresence(true, true);
    // create offers if participants exist
    // we already create offers on participant join; but now add tracks to existing pc senders
    Object.values(pcs).forEach(pc => {
      const senders = pc.getSenders().filter(s => s.track && s.track.kind === 'video');
      const localVideoTrack = localStream.getVideoTracks()[0];
      if(localVideoTrack && senders.length) {
        senders.forEach(s => { try{ s.replaceTrack(localVideoTrack); }catch(e){} });
      } else if(localVideoTrack){
        // no sender? try addTrack (some browsers may require renegotiation)
        try{ pc.addTrack(localVideoTrack, localStream); }catch(e){}
      }
      const audioSenders = pc.getSenders().filter(s => s.track && s.track.kind === 'audio');
      const localAudioTrack = localStream.getAudioTracks()[0];
      if(localAudioTrack && audioSenders.length){
        audioSenders.forEach(s => { try{ s.replaceTrack(localAudioTrack); }catch(e){} });
      } else if(localAudioTrack){
        try{ pc.addTrack(localAudioTrack, localStream); }catch(e){}
      }
    });
    // ensure presence node uses onDisconnect (if not set)
    try{ onDisconnect(ref(db, `rooms/${roomId}/participants/${me.uid}`)).remove(); }catch(e){}
    // update buttons UI
    updateControlButtons();
  } else {
    // permission denied or error - set flags accordingly, but don't kick out
    const err = result.error;
    console.warn('Media request failed', err);
    if(err && (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError')){
      // user denied; for cameras we cannot differentiate easily audio vs video, so attempt each separately
      const camTry = await tryGetMedia({ video:true });
      permissionDeniedCam = !camTry.ok && camTry.error && (camTry.error.name === 'NotAllowedError' || camTry.error.name === 'PermissionDeniedError');
      const micTry = await tryGetMedia({ audio:true });
      permissionDeniedMic = !micTry.ok && micTry.error && (micTry.error.name === 'NotAllowedError' || micTry.error.name === 'PermissionDeniedError');
    }
    // update presence to reflect no cam/mic
    localStream = null;
    localCamEnabled = false;
    localMicEnabled = false;
    updateMyPresence(false, false);
    updateControlButtons();
  }
};

// initial attempt to get media but tolerant: if denied, do not leave room
async function initialMediaAcquire(){
  // try to get both but tolerate fail
  const res = await tryGetMedia({ video:true, audio:true });
  if(res.ok){
    localStream = res.stream;
    localCamEnabled = true; localMicEnabled = true;
  } else {
    // if combined fails, try each separately to determine which denied
    const camRes = await tryGetMedia({ video:true });
    localCamEnabled = camRes.ok;
    const micRes = await tryGetMedia({ audio:true });
    localMicEnabled = micRes.ok;
    if(camRes.ok) localStream = camRes.stream;
    else if(micRes.ok) localStream = micRes.stream;
    else localStream = null;
    permissionDeniedCam = camRes.error && (camRes.error.name === 'NotAllowedError' || camRes.error.name === 'PermissionDeniedError');
    permissionDeniedMic = micRes.error && (micRes.error.name === 'NotAllowedError' || micRes.error.name === 'PermissionDeniedError');
  }
  // create local tile even if no stream
  const t = ensureTile(me.uid, me.displayName);
  if(localStream){
    t.video.srcObject = localStream;
    t.video.style.display = localCamEnabled ? 'block' : 'none';
    t.avatar.style.display = localCamEnabled ? 'none' : 'flex';
    if(localMicEnabled) startVADFor(me.uid, localStream, true);
  } else {
    t.video.style.display = 'none'; t.avatar.style.display = 'flex';
  }
  updateControlButtons();
}

// update control buttons UI (colors/disabled states)
function updateControlButtons(){
  // mic button
  if(permissionDeniedMic){
    muteBtn.classList.add('no-perm'); muteBtn.classList.remove('dim');
    muteBtn.innerText = 'MIC';
    muteBtn.disabled = true;
  }else{
    muteBtn.disabled = false;
    if(localMicEnabled){
      muteBtn.classList.remove('dim'); muteBtn.innerText = 'MIC';
    } else {
      muteBtn.classList.add('dim'); muteBtn.innerText = 'MIC OFF';
    }
  }
  // cam button
  if(permissionDeniedCam){
    camBtn.classList.add('no-perm'); camBtn.classList.remove('dim');
    camBtn.innerText = 'CAM';
    camBtn.disabled = true;
  }else{
    camBtn.disabled = false;
    if(localCamEnabled){
      camBtn.classList.remove('dim'); camBtn.innerText = 'CAM';
    } else {
      camBtn.classList.add('dim'); camBtn.innerText = 'CAM OFF';
    }
  }
}

// toggle mic - if permission not granted, ask user to enable via EnablePerm button
muteBtn.onclick = async ()=>{
  if(permissionDeniedMic){ alert('Bạn chưa cấp quyền Micro. Nhấn ⚙️ để bật quyền.'); return; }
  if(!localStream){
    // ask for mic permission specifically
    const r = await tryGetMedia({ audio:true });
    if(r.ok){ localStream = r.stream; localMicEnabled = true; if(r.stream.getVideoTracks().length) localCamEnabled = true; updateMyPresence(localCamEnabled, localMicEnabled); const t = ensureTile(me.uid, me.displayName); t.video.srcObject = localStream; startVADFor(me.uid, localStream, true); updateControlButtons(); return; }
    else { permissionDeniedMic = r.error && (r.error.name === 'NotAllowedError' || r.error.name === 'PermissionDeniedError'); updateControlButtons(); return; }
  }
  // toggle audio track if exists
  const at = localStream.getAudioTracks()[0];
  if(at){
    at.enabled = !at.enabled; localMicEnabled = at.enabled;
    updateMyPresence(localCamEnabled, localMicEnabled);
    if(localMicEnabled) startVADFor(me.uid, localStream, true);
    else { if(vadIntervals[me.uid]) { cancelAnimationFrame(vadIntervals[me.uid]); delete vadIntervals[me.uid]; } muteBtn.classList.remove('mic-active'); }
    updateControlButtons();
  } else {
    // attempt to get audio
    const r = await tryGetMedia({ audio:true });
    if(r.ok){ localStream = localStream ? new MediaStream([...localStream.getTracks(), ...r.stream.getAudioTracks()]) : r.stream; localMicEnabled = true; updateMyPresence(localCamEnabled, localMicEnabled); startVADFor(me.uid, localStream, true); updateControlButtons(); }
    else { permissionDeniedMic = r.error && (r.error.name === 'NotAllowedError' || r.error.name === 'PermissionDeniedError'); updateControlButtons(); }
  }
};

// toggle cam - similar to mic
camBtn.onclick = async ()=>{
  if(permissionDeniedCam){ alert('Bạn chưa cấp quyền Camera. Nhấn ⚙️ để bật quyền.'); return; }
  if(!localStream){
    const r = await tryGetMedia({ video:true });
    if(r.ok){ localStream = r.stream; localCamEnabled = true; if(r.stream.getAudioTracks().length) localMicEnabled = true; updateMyPresence(localCamEnabled, localMicEnabled); const t = ensureTile(me.uid, me.displayName); t.video.srcObject = localStream; t.video.style.display='block'; t.avatar.style.display='none'; updateControlButtons(); return; }
    else { permissionDeniedCam = r.error && (r.error.name === 'NotAllowedError' || r.error.name === 'PermissionDeniedError'); updateControlButtons(); return; }
  }
  const vt = localStream.getVideoTracks()[0];
  if(vt){
    vt.enabled = !vt.enabled; localCamEnabled = vt.enabled;
    const t = tiles[me.uid];
    if(t){ t.video.style.display = localCamEnabled ? 'block' : 'none'; t.avatar.style.display = localCamEnabled ? 'none' : 'flex'; }
    updateMyPresence(localCamEnabled, localMicEnabled);
    updateControlButtons();
  } else {
    const r = await tryGetMedia({ video:true });
    if(r.ok){ if(localStream) { r.stream.getVideoTracks().forEach(tr=> localStream.addTrack(tr)); } else localStream = r.stream; localCamEnabled = true; updateMyPresence(localCamEnabled, localMicEnabled); const t = tiles[me.uid]; if(t){ t.video.srcObject = localStream; t.video.style.display='block'; t.avatar.style.display='none'; } updateControlButtons(); } else { permissionDeniedCam = r.error && (r.error.name === 'NotAllowedError' || r.error.name === 'PermissionDeniedError'); updateControlButtons(); }
  }
};

// leave
leaveBtn.onclick = async ()=>{
  try{ await remove(ref(db, `rooms/${roomId}/participants/${me.uid}`)); }catch(e){}
  Object.keys(pcs).forEach(k=>closePeer(k));
  if(localStream) localStream.getTracks().forEach(t=>t.stop());
  location.href='index.html';
};

// initial auth and init
let firstCheck = true;
onAuthStateChanged(auth, async user=>{
  if(user){
    firstCheck = false;
    const uid = user.uid;
    const usnap = await get(ref(db, `users/${uid}`));
    const data = usnap.val();
    if(!data){ alert('Không tìm thấy profile'); location.href='login.html'; return; }
    me = { uid, username:data.username, displayName:data.displayName };
    meInfo.innerText = me.displayName; meName.innerText = me.displayName;
    // set room title
    if(!roomId){ roomId = prompt('Nhập Room ID'); if(!roomId) { location.href = 'index.html'; return; } }
    roomTitle.innerText = 'Room: ' + roomId;
    // attempt to acquire media but tolerant
    await initialMediaAcquire();
    // join DB participants
    await joinRoomNode();
    // listen participants & signals
    watchParticipants();
    listenSignalsForMyself();
  } else {
    if(!firstCheck) location.href='login.html';
  }
});

// helper handleSignal / peers functions already defined above

// small utilities: invite button opens friend list (simple prompt)
inviteBtn.onclick = async ()=>{
  // fetch friends list
  if(!me) return alert('Chưa đăng nhập');
  const snap = await get(ref(db, `users/${me.uid}/friends`));
  const f = snap.val() || {};
  const keys = Object.keys(f);
  if(!keys.length) return alert('Bạn chưa có bạn bè');
  const list = keys.map(k => k).join('\n');
  const to = prompt('Nhập uid người muốn mời (từ danh sách):\n' + list);
  if(!to) return;
  await push(ref(db, `invites/${to}`), { from: me.uid, fromName: me.displayName, room: roomId, time: Date.now() });
  alert('Đã gửi invite');
};

</script>
</body>
</html>
