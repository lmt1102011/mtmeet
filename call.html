<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>MTMET — Video Call PRO</title>
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='16' fill='%2312192a'/%3E%3Ctext x='50'%20y='58' font-size='52' text-anchor='middle' fill='%23ffffff' font-family='Arial'%3EM%3C/text%3E%3C/svg%3E">
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

:root {
  --bg: #0f172a;
  --surface: #1a2847;
  --surface-hover: #232f4d;
  --accent: #3b82f6;
  --accent-hover: #2563eb;
  --success: #10b981;
  --danger: #ef4444;
  --text: #f1f5f9;
  --text-secondary: #cbd5e1;
  --muted: #94a3b8;
  --border: #334155;
  --tile-radius: 16px;
}

* { box-sizing: border-box; }

body {
  margin: 0;
  height: 100vh;
  background: linear-gradient(135deg, #0f172a 0%, #1a2847 100%);
  color: var(--text);
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

header {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 16px 24px;
  background: rgba(26, 40, 71, 0.8);
  border-bottom: 1px solid var(--border);
  backdrop-filter: blur(8px);
}

.logo {
  width: 48px;
  height: 48px;
  border-radius: 12px;
  background: linear-gradient(135deg, #3b82f6 0%, #60a5fa 100%);
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  font-size: 24px;
  color: #fff;
  flex-shrink: 0;
}

header > div:nth-child(2) {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

#roomTitle {
  font-weight: 700;
  font-size: 18px;
  color: var(--text);
  line-height: 1.2;
}

#meInfo {
  font-size: 12px;
  color: var(--muted);
  font-weight: 500;
}

.header-right {
  margin-left: auto;
  display: flex;
  gap: 12px;
  align-items: center;
}

#meName {
  font-size: 14px;
  font-weight: 500;
  color: var(--text-secondary);
}

#inviteBtn {
  background: var(--surface);
  border: 1px solid var(--border);
  color: var(--accent);
  padding: 10px 16px;
  border-radius: 10px;
  cursor: pointer;
  font-weight: 600;
  font-size: 13px;
  transition: all 0.2s ease;
}

#inviteBtn:hover {
  background: var(--surface-hover);
  border-color: var(--accent);
  color: var(--accent-hover);
}

#stageWrap {
  flex: 1;
  overflow: auto;
  padding: 24px;
}

#stage {
  display: grid;
  gap: 16px;
  align-content: start;
  grid-auto-rows: 1fr;
}

.tile {
  background: linear-gradient(135deg, #1a2847 0%, #0f172a 100%);
  border: 1px solid var(--border);
  border-radius: var(--tile-radius);
  overflow: hidden;
  position: relative;
  min-height: 120px;
  display: flex;
  align-items: center;
  justify-content: center;
  aspect-ratio: 16 / 9;
  transition: border-color 0.2s ease, box-shadow 0.2s ease;
}

.tile:hover {
  border-color: var(--accent);
  box-shadow: 0 0 20px rgba(59, 130, 246, 0.15);
}

.tile video {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
}

/* Self-view mirroring helper: toggle with double-click on camera button */
.selfVideo.mirrored {
  transform: scaleX(-1);
}

.tile .avatar {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 56px;
  font-weight: 700;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: #fff;
}

.tile .bottomBar {
  position: absolute;
  left: 14px;
  right: 14px;
  bottom: 14px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
}

.badge {
  background: rgba(15, 23, 42, 0.85);
  padding: 8px 14px;
  border-radius: 10px;
  font-weight: 600;
  color: var(--text);
  font-size: 13px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(8px);
}

.micDot {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: #6b7280;
  margin-left: 8px;
  transition: all 0.2s ease;
}

.micOn {
  background: var(--success);
  box-shadow: 0 0 12px rgba(16, 185, 129, 0.5);
}

.controls {
  position: fixed;
  bottom: 28px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(26, 40, 71, 0.95);
  padding: 14px 18px;
  border-radius: 50px;
  display: flex;
  gap: 14px;
  box-shadow: 0 12px 36px rgba(0, 0, 0, 0.4);
  z-index: 40;
  border: 1px solid var(--border);
  backdrop-filter: blur(10px);
}

.controlBtn {
  width: 60px;
  height: 60px;
  border-radius: 50%;
  border: none;
  background: linear-gradient(135deg, #3b82f6 0%, #60a5fa 100%);
  color: #fff;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  font-size: 20px;
  transition: all 0.2s ease;
}

.controlBtn:hover {
  background: linear-gradient(135deg, #2563eb 0%, #3b82f6 100%);
  box-shadow: 0 6px 16px rgba(59, 130, 246, 0.35);
}

.controlBtn:active {
  transform: scale(0.95);
}

.controlBtn.dim {
  background: linear-gradient(135deg, #4b5563 0%, #6b7486 100%);
  cursor: not-allowed;
  opacity: 0.7;
}

.controlBtn.danger {
  background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
}

.controlBtn.danger:hover {
  background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
  box-shadow: 0 6px 16px rgba(239, 68, 68, 0.35);
}

.controlBtn.no-perm {
  background: linear-gradient(135deg, #7f1d1d 0%, #991b1b 100%);
}

.controlBtn.mic-active {
  box-shadow: 0 0 16px rgba(16, 185, 129, 0.6), inset 0 0 8px rgba(16, 185, 129, 0.2);
}

/* Popup invite */
.popup {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.75);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 999;
  backdrop-filter: blur(4px);
}

.popup.hidden {
  display: none;
}

.popupContent {
  width: 400px;
  max-height: 70vh;
  background: linear-gradient(135deg, var(--surface) 0%, rgba(26, 40, 71, 0.9) 100%);
  border-radius: 20px;
  overflow: auto;
  padding: 24px;
  box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
  border: 1px solid var(--border);
}

.popupHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  font-size: 20px;
  font-weight: 700;
  color: var(--text);
}

.closeBtn {
  border: none;
  background: transparent;
  color: var(--muted);
  font-size: 24px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.closeBtn:hover {
  color: var(--text);
}

.friendList .item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 14px;
  border-radius: 12px;
  background: rgba(255, 255, 255, 0.02);
  margin-bottom: 10px;
  border: 1px solid var(--border);
  transition: all 0.2s ease;
}

.friendList .item:hover {
  background: rgba(59, 130, 246, 0.08);
  border-color: var(--accent);
}

.friendAvatar {
  width: 44px;
  height: 44px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  font-size: 20px;
  color: #fff;
  margin-right: 12px;
  flex-shrink: 0;
}

.inviteBtn {
  padding: 8px 14px;
  border-radius: 10px;
  border: none;
  cursor: pointer;
  background: var(--accent);
  color: #fff;
  font-weight: 600;
  font-size: 12px;
  transition: all 0.2s ease;
}

.inviteBtn:hover {
  background: var(--accent-hover);
  box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
}

.inviteBtn.sent {
  background: var(--muted);
  cursor: not-allowed;
  opacity: 0.5;
}

.actionBtn {
  background: rgba(0, 0, 0, 0.5);
  border: none;
  color: #fff;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  cursor: pointer;
  font-size: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.actionBtn:hover {
  background: rgba(59, 130, 246, 0.6);
}

.peerMenu {
  position: fixed;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 10px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
  z-index: 999;
  min-width: 150px;
  padding: 4px 0;
}

.peerMenu button {
  width: 100%;
  padding: 10px 14px;
  border: none;
  background: transparent;
  color: var(--text);
  cursor: pointer;
  text-align: left;
  font-size: 13px;
  transition: all 0.2s ease;
}

.peerMenu button:hover {
  background: var(--surface-light);
  color: var(--accent);
}

.peerMenu button.danger:hover {
  background: rgba(239, 68, 68, 0.2);
  color: var(--danger);
}

@media (min-width: 1400px) { #stage { grid-template-columns: repeat(4, 1fr); } }
@media (max-width: 1399px) and (min-width: 900px) { #stage { grid-template-columns: repeat(3, 1fr); } }
@media (max-width: 899px) and (min-width: 600px) { #stage { grid-template-columns: repeat(2, 1fr); } }
@media (max-width: 599px) { #stage { grid-template-columns: repeat(1, 1fr); } }

.small { font-size: 13px; color: var(--muted); }
.hidden { display: none; }
.debug-override { display: none !important; }
#debugPanel, #dbgContent, #dbgClear { display: none !important; }

/* Mobile optimizations */
@media (max-width: 768px) {
  header {
    padding: 12px 16px;
    gap: 10px;
  }
  
  .logo {
    width: 40px;
    height: 40px;
    font-size: 20px;
  }
  
  header > div:nth-child(2) {
    gap: 2px;
  }
  
  #roomTitle {
    font-size: 16px;
  }
  
  #meInfo {
    font-size: 11px;
  }
  
  #meName {
    font-size: 12px;
  }
  
  #inviteBtn {
    padding: 8px 12px;
    font-size: 12px;
  }
  
  #stageWrap {
    padding: 12px;
  }
  
  #stage {
    gap: 12px;
  }
  
  .tile {
    min-height: 100px;
    border-radius: 12px;
  }
  
  .tile .bottomBar {
    left: 10px;
    right: 10px;
    bottom: 10px;
    gap: 8px;
  }
  
  .badge {
    padding: 6px 10px;
    font-size: 12px;
  }
  
  .micDot {
    width: 10px;
    height: 10px;
    margin-left: 6px;
  }
  
  .controls {
    bottom: 16px;
    padding: 10px 12px;
    gap: 10px;
  }
  
  .controlBtn {
    width: 50px;
    height: 50px;
    font-size: 18px;
  }
  
  .popupContent {
    width: 90%;
    max-width: 380px;
    padding: 18px;
  }
  
  .popupHeader {
    font-size: 18px;
    margin-bottom: 16px;
  }
  
  .friendList .item {
    padding: 12px;
    margin-bottom: 8px;
  }
  
  .friendAvatar {
    width: 40px;
    height: 40px;
    font-size: 18px;
    margin-right: 10px;
  }
  
  .inviteBtn {
    padding: 6px 10px;
    font-size: 11px;
  }
}

@media (max-width: 480px) {
  header {
    padding: 10px 12px;
  }
  
  .logo {
    width: 36px;
    height: 36px;
    font-size: 18px;
  }
  
  #roomTitle {
    font-size: 14px;
  }
  
  #meInfo {
    font-size: 10px;
  }
  
  #inviteBtn {
    padding: 6px 10px;
    font-size: 11px;
  }
  
  #stageWrap {
    padding: 8px;
  }
  
  #stage {
    gap: 8px;
    grid-template-columns: 1fr !important;
  }
  
  .tile {
    min-height: 80px;
  }
  
  .controls {
    bottom: 12px;
    padding: 8px 10px;
    gap: 8px;
  }
  
  .controlBtn {
    width: 44px;
    height: 44px;
    font-size: 16px;
  }
  
  .popupContent {
    width: 95%;
    padding: 16px;
    border-radius: 16px;
  }
  
  .friendList .item {
    flex-direction: column;
    gap: 8px;
    align-items: flex-start;
  }
}
</style>
</head>
<body>

<header>
  <div class="logo">M</div>
  <div>
    <div id="roomTitle">Room</div>
    <div id="meInfo" class="small">...</div>
  </div>
  <div class="header-right">
    <div id="meName" class="small"></div>
    <button id="inviteBtn">Invite</button>
  </div>
</header>

<div id="stageWrap"><div id="stage"></div></div>

<!-- Debug panel removed -->

<div class="controls">
  <button id="requestPermBtn" class="controlBtn" title="Enable Camera & Mic">SET</button>
  <button id="muteBtn" class="controlBtn dim" title="Toggle mic">MIC</button>
  <button id="camBtn" class="controlBtn dim" title="Toggle cam">CAM</button>
  <button id="leaveBtn" class="controlBtn danger" title="Leave">✖</button>
</div>

<!-- Invite Popup -->
<div id="invitePopup" class="popup hidden">
  <div class="popupContent">
    <div class="popupHeader">
      <div>Chọn bạn để mời</div>
      <button id="closeInvite" class="closeBtn">✖</button>
    </div>
    <div id="friendList" class="friendList"></div>
  </div>
</div>

<script src="firebase-config.js"></script>
<script type="module">
import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js';
import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-auth.js';
import { getDatabase, ref, set, onValue, push, get, remove, update } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-database.js';
import { getStorage, ref as storageRef, uploadBytes } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-storage.js';

const app = initializeApp(window.FIREBASE_CONFIG);
const auth = getAuth(app);
const db = getDatabase(app);
const storage = getStorage(app);

console.debug('call.html loaded with DB URL:', window.FIREBASE_CONFIG && window.FIREBASE_CONFIG.databaseURL);

// Debug helpers - controlled by DEBUG flag
const DEBUG = false;
let dbgLog = [];
const dbgContent = document.getElementById('dbgContent');
const dbgClear = document.getElementById('dbgClear');
function dbg(msg){
  const ts = new Date().toLocaleTimeString();
  const line = `[${ts}] ${msg}`;
  // Maintain recent log buffer only when DEBUG enabled
  if(DEBUG){
    dbgLog.push(line);
    if(dbgLog.length > 60) dbgLog.shift();
    if(dbgContent) dbgContent.innerText = dbgLog.join('\n');
    console.debug(line);
  }
}
if(dbgClear) dbgClear.onclick = ()=>{ dbgLog = []; if(dbgContent) dbgContent.innerText = ''; };
if(DEBUG) dbg('=== DEBUG PANEL ACTIVE ===');

// Check auth state and wait for user data to load
let authReadyPromise = new Promise((resolve) => {
  onAuthStateChanged(auth, async user => {
    if (!user) {
      location.href = 'login.html';
      return;
    }
    window.currentUser = { uid: user.uid };
    console.debug('call.html auth user:', user.uid);
    
    // Load user display name from DB
    try {
      const userSnap = await get(ref(db, `users/${user.uid}`));
      const userData = userSnap.val();
      if (userData) {
        window.currentUser.displayName = userData.displayName;
        window.currentUser.username = userData.username;
        console.debug('call.html user data loaded:', window.currentUser);
      } else {
        console.warn('User data not found for:', user.uid);
      }
    } catch (e) {
      console.error('Error loading user data:', e);
    }
    resolve(window.currentUser);
  });
});


const stage = document.getElementById('stage');
const meInfo = document.getElementById('meInfo');
const meName = document.getElementById('meName');
const inviteBtn = document.getElementById('inviteBtn');
const requestPermBtn = document.getElementById('requestPermBtn');
const muteBtn = document.getElementById('muteBtn');
const camBtn = document.getElementById('camBtn');
const leaveBtn = document.getElementById('leaveBtn');
const invitePopup = document.getElementById('invitePopup');
const friendListDiv = document.getElementById('friendList');
const closeInvite = document.getElementById('closeInvite');

let roomId = new URLSearchParams(location.search).get('room') || "demo-room";

// Will be filled from Firebase auth (via Promise)
let uid = null;
let username = null;
let displayName = null;

// Wait for auth to be ready
authReadyPromise.then(() => {
  const user = window.currentUser;
  uid = user.uid;
  username = user.username;
  displayName = user.displayName || user.username;
  
  // Initialize me object with user data
  me = { uid, username, displayName, friends: {} };
  
  console.debug('Auth ready - uid:', uid, 'username:', username, 'displayName:', displayName);
  
  meName.innerText = displayName;
  meInfo.innerText = uid;
  
  // Auto-request media permissions when auth is ready
  dbg('Auth ready. Auto-requesting media permissions...');
  requestPermissions();
}).catch(err => {
  console.error('Failed to load auth:', err);
  alert('Lỗi tải thông tin người dùng');
});

let localStream=null;
let localMicEnabled=false;
let localCamEnabled=false;
let localMirror = false; // whether to mirror self-view horizontally
let me = null; // Current user object {uid, username, displayName, friends}
let pcs = {};
let tiles = {};
let audioAnalyzers = {};
let iceCandidateBuffer = {};
let audioBuffers = {}; // Store 20s audio ring buffers per peer
let mediaRecorders = {}; // MediaRecorder per peer

function elt(t,attrs={},txt=''){ const e=document.createElement(t); for(const k in attrs) e.setAttribute(k,attrs[k]); if(txt) e.innerText=txt; return e; }
function relayout(){
  const count = Math.max(1, Object.keys(tiles).length);
  const w = stage.clientWidth || window.innerWidth;
  // Prefer a near-square layout: columns ~= ceil(sqrt(count))
  let cols = Math.ceil(Math.sqrt(count));
  // Limit columns by available width (target min tile width ~280px)
  const maxColsByWidth = Math.max(1, Math.floor(w / 280));
  cols = Math.min(cols, maxColsByWidth);
  cols = Math.min(cols, count);
  stage.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
  stage.style.gridAutoRows = '1fr';
}
window.addEventListener('resize',relayout);

function createTile(uid,name){
  if(tiles[uid]) return tiles[uid];
  const tile = elt('div',{class:'tile'});
  const video = elt('video',{autoplay:true,playsinline:true});
  const safeName = (name && String(name).trim()) ? String(name).trim() : 'U';
  const avatarInitial = (safeName && safeName[0]) ? safeName[0].toUpperCase() : 'U';
  const avatar = elt('div',{class:'avatar'},avatarInitial);
  const bottomBar = elt('div',{class:'bottomBar'});
  const badge = elt('div',{class:'badge'},name);
  const micDot = elt('div',{class:'micDot'});
  
  // Action button (...)
  const actionBtn = elt('button',{class:'actionBtn'},'...');
  actionBtn.onclick = (e)=>{ e.stopPropagation(); showPeerMenu(uid, name, actionBtn); };
  
  bottomBar.appendChild(badge); bottomBar.appendChild(micDot); bottomBar.appendChild(actionBtn);
  tile.appendChild(video); tile.appendChild(avatar); tile.appendChild(bottomBar);
  stage.appendChild(tile);
  tiles[uid]={el:tile,video,avatar,badge,micDot,uid,name};
  // Hide avatar automatically when video starts playing
  const hideAvatarOnPlay = ()=>{
    console.log(`Video event triggered for ${uid}: hiding avatar`);
    if(tiles[uid] && tiles[uid].avatar) {
      tiles[uid].avatar.style.display = 'none';
    }
  };
  video.addEventListener('loadedmetadata', hideAvatarOnPlay);
  video.addEventListener('play', hideAvatarOnPlay);
  video.addEventListener('playing', hideAvatarOnPlay);
  // If the stream is removed or video has no tracks, show avatar again
  video.addEventListener('emptied', ()=>{ 
    console.log(`Video emptied for ${uid}: showing avatar`);
    if(tiles[uid] && tiles[uid].avatar) tiles[uid].avatar.style.display = ''; 
  });
  
  // Debug: log when srcObject is set
  video.addEventListener('loadstart', ()=>{ console.log(`Video loadstart for ${uid}`); });
  video.addEventListener('canplay', ()=>{ console.log(`Video canplay for ${uid}`); });
  video.addEventListener('error', (e)=>{ console.error(`Video error for ${uid}:`, e); });
  
  // Allow user to click video to play if autoplay fails
  video.addEventListener('click', ()=>{
    if(video.paused || video.readyState < 3) {
      video.play().catch(err => console.warn(`Manual play failed for ${uid}:`, err));
    }
  });
  
  // Add a play button overlay if video doesn't autoplay
  const playOverlay = elt('div', {class:'playOverlay'}, '▶ Click to play');
  playOverlay.style.cssText = `
    position: absolute; 
    top: 50%; 
    left: 50%; 
    transform: translate(-50%, -50%); 
    background: rgba(0,0,0,0.7); 
    color: white; 
    padding: 8px 12px; 
    border-radius: 6px; 
    font-size: 12px; 
    pointer-events: none; 
    opacity: 0; 
    transition: opacity 0.3s;
  `;
  tile.appendChild(playOverlay);
  
  // Show overlay if video doesn't play automatically
  setTimeout(() => {
    if(video.paused && tiles[uid] && tiles[uid].video.srcObject) {
      playOverlay.style.opacity = '1';
      playOverlay.style.pointerEvents = 'auto';
    }
  }, 2000); // Wait 2 seconds for autoplay attempt
  
  // Hide overlay when video starts playing
  video.addEventListener('play', () => { playOverlay.style.opacity = '0'; playOverlay.style.pointerEvents = 'none'; });
  relayout();
  return tiles[uid];
}

async function requestPermissions(){
  if (!username || !uid) {
    alert('Chưa tải thông tin người dùng');
    return;
  }
  
  // Try to get media with graceful fallback
  let stream = null;
  let mediaType = null;
  
  // Try 1: video + audio
  try {
    dbg('Attempting: video + audio...');
    stream = await navigator.mediaDevices.getUserMedia({video:true,audio:{echoCancellation:true,noiseSuppression:true}});
    mediaType = 'video+audio';
    dbg('✓ getUserMedia success - camera & mic granted');
  } catch(e1) {
    dbg(`✗ video+audio failed (${e1.name}), trying audio-only...`);
    // Try 2: audio only
    try {
      stream = await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:true,noiseSuppression:true}});
      mediaType = 'audio';
      dbg('✓ getUserMedia success - mic granted (no camera)');
    } catch(e2) {
      dbg(`✗ audio-only failed (${e2.name}), trying video-only...`);
      // Try 3: video only
      try {
        stream = await navigator.mediaDevices.getUserMedia({video:true});
        mediaType = 'video';
        dbg('✓ getUserMedia success - camera granted (no mic)');
      } catch(e3) {
        dbg(`✗ video-only failed (${e3.name}). Joining room without local stream.`);
        console.error('All media requests failed:', e1, e2, e3);
        camBtn.classList.add('no-perm'); 
        muteBtn.classList.add('no-perm');
        joinRoom(); // Join without local stream
        return;
      }
    }
  }

  if (!stream) {
    dbg('No stream obtained. Joining room without local stream.');
    joinRoom();
    return;
  }

  localStream = stream;
  localCamEnabled = (mediaType === 'video+audio' || mediaType === 'video');
  localMicEnabled = (mediaType === 'video+audio' || mediaType === 'audio');
  
  console.log(`✓ Đã cấp quyền (${mediaType})`);
  
  tiles['me']=createTile('me', username);
  tiles['me'].video.srcObject=localStream;
  // Apply mirror setting for local view
  try{ tiles['me'].video.style.transform = localMirror ? 'scaleX(-1)' : ''; }catch(_){ }
  // Mute local playback so you don't hear your own microphone (self-monitoring)
  try{ 
    tiles['me'].video.muted = true; 
    tiles['me'].video.volume = 0;
    // Don't hide avatar immediately - let loadedmetadata event do it
  }catch(_){ }
  
  // Remove dim and no-perm classes if we have media
  if(localCamEnabled) { camBtn.classList.remove('dim','no-perm'); camBtn.classList.add('mic-active'); }
  if(localMicEnabled) { muteBtn.classList.remove('dim','no-perm'); muteBtn.classList.add('mic-active'); }
  
  if(localMicEnabled) startMicAnalyzer('me',localStream);
  
  // Load friends list to check friend status in peer menu
  try {
    const friendsSnap = await get(ref(db, `users/${uid}/friends`));
    const friendsData = friendsSnap.val();
    if(friendsData && me) {
      me.friends = friendsData;
      console.debug('Friends loaded:', Object.keys(friendsData).length);
    }
  } catch(e) {
    console.error('Error loading friends:', e);
  }
  
  // Add local tracks to existing peer connections if they were created before localStream
  Object.values(pcs).forEach(pc => {
    if (localStream) {
      localStream.getTracks().forEach(track => {
        if (!pc.getSenders().some(sender => sender.track === track)) {
          pc.addTrack(track, localStream);
        }
      });
    }
  });
  
  joinRoom();
}

muteBtn.onclick = ()=>{ 
  if(!localStream) { 
    console.warn('No local stream yet'); 
    return; 
  } 
  localMicEnabled = !localMicEnabled; 
  localStream.getAudioTracks().forEach(t => t.enabled = localMicEnabled);
  muteBtn.classList.toggle('mic-active', localMicEnabled);
};

camBtn.onclick = ()=>{ 
  if(!localStream) { 
    console.warn('No local stream yet'); 
    return; 
  } 
  localCamEnabled = !localCamEnabled; 
  localStream.getVideoTracks().forEach(t => t.enabled = localCamEnabled);
  camBtn.classList.toggle('dim', !localCamEnabled);
};

// Double-click the cam button to toggle horizontal mirror for self-view
camBtn.ondblclick = ()=>{
  localMirror = !localMirror;
  if(tiles['me'] && tiles['me'].video) {
    tiles['me'].video.style.transform = localMirror ? 'scaleX(-1)' : '';
  }
  camBtn.title = localMirror ? 'Camera (mirrored)' : 'Camera (normal)';
  console.log('localMirror set to', localMirror);
};

leaveBtn.onclick = async ()=>{ 
  Object.values(pcs).forEach(pc=>pc.close()); 
  if (uid) {
    try {
      await remove(ref(db, `rooms/${roomId}/participants/${uid}`));
    } catch(e) {
      console.error('Error removing participant:', e);
    }
  }
  location.href="index.html"; 
};

requestPermBtn.onclick = ()=>{
  if (!uid) {
    console.error('uid not yet loaded');
    alert('Đang tải thông tin người dùng, vui lòng chờ...');
    return;
  }
  requestPermissions();
};

inviteBtn.onclick=()=>{ invitePopup.classList.remove('hidden'); loadFriends(); };
closeInvite.onclick=()=>{ invitePopup.classList.add('hidden'); }

async function loadFriends(){
  friendListDiv.innerHTML='<div style="color:#ccc;padding:10px;">Đang tải...</div>';
  try {
    // Load current user's friends list
    const myFriendsSnap = await get(ref(db, `users/${uid}/friends`));
    const myFriends = myFriendsSnap.val() || {};
    const friendIds = Object.keys(myFriends);
    
    if(friendIds.length === 0){
      friendListDiv.innerHTML='<div style="color:#ccc;padding:10px;">Bạn chưa có bạn bè nào</div>';
      return;
    }
    
    // Load friend details from users node
    const usersSnap = await get(ref(db, 'users'));
    const allUsers = usersSnap.val() || {};
    friendListDiv.innerHTML='';
    
    friendIds.forEach(fid=>{
      const f = allUsers[fid];
      if(!f) return; // Skip if friend data not found
      
      const item = elt('div',{class:'item'});
      const avatar = elt('div',{class:'friendAvatar'}, (f.displayName || f.username || 'U')[0].toUpperCase());
      const name = elt('div',{}, f.displayName || f.username);
      const btn = elt('button',{class:'inviteBtn'},'Mời');
      btn.onclick = async ()=>{
        const inviteKey = 'i_'+Math.random().toString(36).slice(2,9);
        await push(ref(db, `invites/${fid}`), {from: uid, fromName: displayName, room: roomId, time: Date.now()});
        btn.classList.add('sent'); btn.innerText='Đã gửi'; btn.disabled=true;
      };
      item.appendChild(avatar); item.appendChild(name); item.appendChild(btn);
      friendListDiv.appendChild(item);
    });
  } catch(e) {
    console.error('loadFriends error:', e);
    friendListDiv.innerHTML='<div style="color:#f44;">Lỗi tải danh sách bạn</div>';
  }
}

let participantsUnsubscribe = null;
let signalsUnsubscribe = null;

function joinRoom(){
  const participantsRef = ref(db, 'rooms/'+roomId+'/participants');
  const signalsRef = ref(db, 'rooms/'+roomId+'/signals');
  
  dbg(`Joining room: ${roomId}`);
  
  // Unsubscribe from old listeners if any (avoid duplicate listeners when re-joining)
  if(participantsUnsubscribe) participantsUnsubscribe();
  if(signalsUnsubscribe) signalsUnsubscribe();
  
  set(ref(db, `rooms/${roomId}/participants/${uid}`), {name: displayName || username});
  
  participantsUnsubscribe = onValue(participantsRef, snap=>{
    const data = snap.val()||{};
    dbg(`Participants: ${Object.keys(data).join(', ')}`);
    Object.keys(data).forEach(pid=>{
      if(pid===uid) return;
      if(!pcs[pid]){ dbg(`Creating peer for ${pid}`); createPeer(pid, data[pid].name); }
    });
    Object.keys(tiles).forEach(tid=>{
      if(tid!=='me' && !data[tid]){ dbg(`Removing tile for ${tid}`); tiles[tid].el.remove(); delete tiles[tid]; pcs[tid]?.close(); delete pcs[tid]; }
    });
  });

  signalsUnsubscribe = onValue(signalsRef, snap=>{
    const signals = snap.val();
    if (!signals) return;
    Object.entries(signals).forEach(([key, s]) => {
      if(!s || s.to !== uid) return;
      dbg(`Signal from ${s.from}: ${s.type}`);
      handleSignal(s.from, s.type, s.data);
      remove(ref(db, `rooms/${roomId}/signals/${key}`));
    });
  });
}

function createPeer(pid, name){
  const pc = new RTCPeerConnection();
  pcs[pid]=pc;
  tiles[pid]=createTile(pid, name);
  iceCandidateBuffer[pid] = []; // initialize buffer for this peer
  
  if(localStream) {
    dbg(`Adding ${localStream.getTracks().length} local tracks to PC for ${pid}`);
    localStream.getTracks().forEach(t=>pc.addTrack(t, localStream));
  } else {
    dbg(`No localStream yet when creating PC for ${pid}`);
  }
  pc.ontrack = e=>{
    dbg(`ontrack from ${pid}: ${e.streams.length} streams, track kind=${e.track.kind}, enabled=${e.track.enabled}`);
    if(tiles[pid]) {
      dbg(`Setting video.srcObject for ${pid}`);
      tiles[pid].video.srcObject = e.streams[0];
      
      // Debug: check if stream has video tracks
      const stream = e.streams[0];
      const videoTracks = stream.getVideoTracks();
      const audioTracks = stream.getAudioTracks();
      console.log(`Stream from ${pid} has ${videoTracks.length} video tracks, ${audioTracks.length} audio tracks`);
      
      // If stream has video tracks, hide avatar immediately
      if(videoTracks.length > 0) {
        tiles[pid].avatar.style.display = 'none';
      }
      
      // Try to play the video
      try {
        const playPromise = tiles[pid].video.play();
        if(playPromise !== undefined) {
          playPromise.catch(err => { console.warn(`Autoplay prevented for ${pid}:`, err); });
        }
      } catch(err) {
        console.warn(`Could not play video for ${pid}:`, err);
      }
      if(e.track.kind === 'audio') startMicAnalyzer(pid, e.streams[0]);
    } else {
      dbg(`ERROR: tile not found for ${pid}`);
    }
  };
  pc.onicecandidate = e=>{
    if(e.candidate) { 
      dbg(`ICE candidate for ${pid}: ${e.candidate.candidate ? e.candidate.candidate.slice(0,50) : '(empty)'}`);
      // Send the full RTCIceCandidate object, not just toJSON()
      const candData = {
        candidate: e.candidate.candidate,
        sdpMLineIndex: e.candidate.sdpMLineIndex,
        sdpMid: e.candidate.sdpMid
      };
      push(ref(db, `rooms/${roomId}/signals`), {from: uid, to: pid, type: 'candidate', data: candData}); 
    }
  };
  pc.oniceconnectionstatechange = ()=>{ dbg(`ICE state ${pid}: ${pc.iceConnectionState}`); };
  pc.onconnectionstatechange = ()=>{ dbg(`Connection state ${pid}: ${pc.connectionState}`); };
  pc.onerror = e=>{ dbg(`PC error for ${pid}: ${e}`); };
  
  // Offer-answer negotiation: only the peer with smaller UID creates offer
  // This avoids race conditions where both peers try to create offers simultaneously
  const shouldCreateOffer = uid < pid;
  
  if(shouldCreateOffer) {
    dbg(`I have smaller UID (${uid} < ${pid}), creating offer...`);
    pc.createOffer().then(o=>{
      dbg(`Sending offer to ${pid}`);
      pc.setLocalDescription(o);
      push(ref(db, `rooms/${roomId}/signals`), {from: uid, to: pid, type: 'offer', data: o});
    }).catch(err=>{ dbg(`Error creating offer for ${pid}: ${err.message}`); });
  } else {
    dbg(`I have larger UID (${uid} > ${pid}), waiting for offer...`);
  }
}

function handleSignal(from, type, data){
  let pc = pcs[from]; 
  if(!pc){ 
    dbg(`PC not found for ${from}, creating...`);
    const peerName = tiles[from]?.badge?.innerText || 'Peer';
    createPeer(from, peerName); 
    pc = pcs[from]; 
  }
  if(type === 'offer'){ 
    dbg(`Handling offer from ${from}`);
    pc.setRemoteDescription(new RTCSessionDescription(data)).then(()=>{ 
      dbg(`Remote description (offer) set for ${from}. Flushing buffered ICE candidates...`);
      // Flush buffered candidates
      if(iceCandidateBuffer[from]) {
        iceCandidateBuffer[from].forEach(cand=>{
          pc.addIceCandidate(new RTCIceCandidate(cand)).catch(err=>{ dbg(`Error adding buffered ICE candidate from ${from}: ${err.message}`); });
        });
        iceCandidateBuffer[from] = [];
      }
      // Only the peer with larger UID creates answer
      if(uid > from) {
        dbg(`I have larger UID (${uid} > ${from}), creating answer...`);
        pc.createAnswer().then(a=>{ 
          dbg(`Sending answer to ${from}`);
          pc.setLocalDescription(a); 
          push(ref(db, `rooms/${roomId}/signals`), {from: uid, to: from, type: 'answer', data: a}); 
        }).catch(err=>{ dbg(`Error creating answer for ${from}: ${err.message}`); }); 
      } else {
        dbg(`I have smaller UID (${uid} < ${from}), NOT creating answer (peer will)`);
      }
    }).catch(err=>{ dbg(`Error setting remote description (offer) from ${from}: ${err.message}`); }); 
  }
  else if(type === 'answer'){ 
    dbg(`Handling answer from ${from}`);
    pc.setRemoteDescription(new RTCSessionDescription(data)).then(()=>{
      dbg(`Remote description (answer) set for ${from}. Flushing buffered ICE candidates...`);
      // Flush buffered candidates
      if(iceCandidateBuffer[from]) {
        iceCandidateBuffer[from].forEach(cand=>{
          pc.addIceCandidate(new RTCIceCandidate(cand)).catch(err=>{ dbg(`Error adding buffered ICE candidate from ${from}: ${err.message}`); });
        });
        iceCandidateBuffer[from] = [];
      }
    }).catch(err=>{ dbg(`Error setting remote description (answer) from ${from}: ${err.message}`); });
  }
  else if(type === 'candidate'){ 
    dbg(`Received ICE candidate from ${from}`);
    // If remote description is not set yet, buffer the candidate
    if(!pc.remoteDescription) {
      dbg(`Buffering ICE candidate from ${from} (remote description not set yet)`);
      if(!iceCandidateBuffer[from]) iceCandidateBuffer[from] = [];
      iceCandidateBuffer[from].push(data);
    } else {
      dbg(`Adding ICE candidate from ${from}`);
      try {
        pc.addIceCandidate(new RTCIceCandidate(data));
      } catch(err) { 
        dbg(`Error adding ICE candidate from ${from}: ${err.message}`); 
      }
    }
  }
}

// Peer action menu
function showPeerMenu(pid, peerName, btn) {
  // Close any existing menu
  const existingMenu = document.querySelector('.peerMenu');
  if(existingMenu) existingMenu.remove();
  
  const menu = document.createElement('div');
  menu.className = 'peerMenu';
  
  // Check if already friend
  const isFriend = me && me.friends && me.friends[pid];
  
  // Add friend button (if not already friend)
  if(!isFriend && me && me.uid !== pid) {
    const btnFriend = document.createElement('button');
    btnFriend.innerText = 'Kết bạn';
    btnFriend.onclick = async ()=>{ 
      try {
        await push(ref(db, `friendRequests/${pid}`), {
          from: me.uid,
          fromName: me.displayName,
          fromUsername: me.username,
          time: Date.now()
        });
        alert('Đã gửi lời mời kết bạn');
      } catch(e) { alert('Lỗi: ' + e.message); }
      try { if(menu) menu.remove(); } catch(e) { console.warn('Menu remove failed:', e); }
    };
    menu.appendChild(btnFriend);
  }
  
  // Report button
  const btnReport = document.createElement('button');
  btnReport.className = 'danger';
  btnReport.innerText = 'Report';
  btnReport.onclick = async ()=>{ 
    if(!confirm('Gửi report người dùng ' + peerName + ' với đoạn âm thanh 20s vừa qua?')) return;
    // Ensure auth present
    if(!auth || !auth.currentUser) { alert('Phiên đăng nhập không hợp lệ. Vui lòng đăng xuất và đăng nhập lại.'); try { if(menu) menu.remove(); } catch(e) { console.warn('Menu remove failed:', e); } return; }

    // Attempt to refresh token silently (best-effort)
    try { await auth.currentUser.getIdToken(true); } catch(_) { /* ignore */ }

    // Get existing ring-buffer audio if available
    let audioBlob = audioBuffers[pid];
    const reporterUid = auth.currentUser.uid;
    const reporterName = displayName || username || auth.currentUser.displayName || 'Unknown';

    // If no pre-recorded audio, try a short 3s capture from the peer's stream (best-effort)
    if(!audioBlob && tiles[pid] && tiles[pid].video && tiles[pid].video.srcObject) {
      try {
        const tmpStream = tiles[pid].video.srcObject;
        const tmpRecorder = new MediaRecorder(tmpStream, { mimeType: 'audio/webm' });
        const tmpChunks = [];
        tmpRecorder.ondataavailable = e=>{ if(e.data && e.data.size) tmpChunks.push(e.data); };
        tmpRecorder.start();
        await new Promise(r => setTimeout(r, 3000));
        tmpRecorder.stop();
        await new Promise(r => { tmpRecorder.onstop = r; });
        if(tmpChunks.length) audioBlob = new Blob(tmpChunks, { type: 'audio/webm' });
      } catch(recErr) { console.warn('Short capture failed:', recErr); }
    }

    try {
      // Create a new report entry and get its key
      const reportsRef = ref(db, 'reports');
      const newRef = push(reportsRef);
      const data = {
        reportedUid: pid,
        reportedName: peerName,
        reporterUid: reporterUid,
        reporterName: reporterName,
        timestamp: Date.now(),
        status: 'pending',
        hasAudio: !!audioBlob
      };
      await set(newRef, data);

      // If we have audio, upload to Storage and update the report node with path
      if(audioBlob) {
        try {
          const path = `reports/${newRef.key}.webm`;
          const sRef = storageRef(storage, path);
          await uploadBytes(sRef, audioBlob);
          await update(ref(db, `reports/${newRef.key}`), { hasAudio: true, audioPath: path });
        } catch(upErr) {
          console.error('Audio upload failed:', upErr);
        }
      }

      alert('Report được gửi thành công' + (audioBlob ? ' (có audio)' : ' (không có audio)'));
      console.log('Report created', newRef.key, 'audio present:', !!audioBlob);
    } catch(e) {
      alert('Lỗi gửi report: ' + (e.message || e));
      console.error('Report error:', e);
    }
    try { if(menu) menu.remove(); } catch(e) { console.warn('Menu remove failed:', e); }
    return;
  }
  };
  menu.appendChild(btnReport);
  
  // Position menu near button
  const rect = btn.getBoundingClientRect();
  menu.style.top = (rect.bottom + 5) + 'px';
  menu.style.left = Math.max(10, rect.left - 100) + 'px';
  
  document.body.appendChild(menu);
  
  // Close menu on outside click
  const closeMenu = (e)=>{ try { if(menu && !menu.contains(e.target) && e.target !== btn) { menu.remove(); document.removeEventListener('click', closeMenu); } } catch(e) { console.warn('Close menu failed:', e); } };
  setTimeout(()=>{ document.addEventListener('click', closeMenu); }, 0);


function startMicAnalyzer(pid,stream){
  const audioCtx = new AudioContext();
  const source = audioCtx.createMediaStreamSource(stream);
  const analyser = audioCtx.createAnalyser();
  analyser.fftSize = 512;
  source.connect(analyser);
  const data = new Uint8Array(analyser.frequencyBinCount);
  audioAnalyzers[pid]=analyser;
  
  // Start recording audio for 20s ring buffer
  try {
    const mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
    mediaRecorders[pid] = mediaRecorder; // Store reference to prevent garbage collection
    let audioChunks = [];
    
    mediaRecorder.ondataavailable = (e)=>{ 
      if(e.data.size > 0) {
        audioChunks.push(e.data);
        console.debug(`Audio chunk for ${pid}:`, e.data.size, 'bytes');
      }
    };
    
    mediaRecorder.onstop = ()=>{ 
      if(audioChunks.length > 0) {
        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
        audioBuffers[pid] = audioBlob;
        console.log(`Saved ${audioChunks.length} audio chunks for ${pid}, total:`, audioBlob.size, 'bytes');
      }
      // Restart recording for next 20s window
      audioChunks = [];
      try {
        mediaRecorder.start();
      } catch(e) {
        console.warn('Could not restart recording for', pid, ':', e.message);
      }
    };
    
    mediaRecorder.start();
    
    // Stop and restart every 20s to keep only last 20s
    const intervalId = setInterval(()=>{ 
      if(mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
      }
    }, 20000);
    
    // Store interval ID for cleanup if needed
    if(!mediaRecorders[pid]) mediaRecorders[pid] = {};
    if(typeof mediaRecorders[pid] !== 'object') mediaRecorders[pid] = mediaRecorder;
    
    console.log(`Audio recording started for ${pid}`);
  } catch(e) {
    console.warn('Could not start audio recording for', pid, ':', e.message);
  }
  
  function tick(){ 
    analyser.getByteFrequencyData(data); 
    const vol = data.reduce((a,b)=>a+b,0)/data.length; 
    const isVoiceActive = vol > 30;
    if(tiles[pid]) {
      tiles[pid].micDot.classList.toggle('micOn', isVoiceActive);
      // Change avatar to green when voice is detected
      if(isVoiceActive && tiles[pid].avatar) {
        tiles[pid].avatar.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
      } else if(tiles[pid].avatar) {
        // Reset to original gradient when voice stops
        tiles[pid].avatar.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
      }
    }
    requestAnimationFrame(tick); 
  }
  tick();
}
</script>
</body>
</html>
